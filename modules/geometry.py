from fenics import *
from mshr import *
import ufl as ufl
import numpy as np


#euclidean  norm of vector x
def my_norm(x):
    return (sqrt( np.dot( x, x ) ))

#norm for UFL vectors
def ufl_norm(x):
    return(sqrt(ufl.dot(x, x)))

epsilon = ufl.PermutationSymbol(2)


#definition of scalar, vectorial and tensorial quantities
#latin indexes run on 2d curvilinear coordinates
i, j, k, l = ufl.indices(4)

#the vector of the differential manifold, which is equal to \vec{X}_{\Gamma}(x_1, x_2) on page 8 if al-izzi2020shear
def X(z):
    x = ufl.SpatialCoordinate(mesh)
    return as_tensor([x[0], x[1], z])

#the vectors tangent to the curvilinear coordinates on the manifold : e(z)[i] = e_i_{al-izzi2020shear}
def e(omega):
    return as_tensor([[1, 0, omega[0]], [0, 1, omega[1]]])

#MAKE SURE THAT THIS NORMAL IS DIRECTED OUTWARDS
#normal(z) = \hat{n}_{al-izzi2020shear}
def normal(omega):
    return as_tensor(cross(e(omega)[0], e(omega)[1]) /  ufl_norm(cross(e(omega)[0], e(omega)[1])) )
#MAKE SURE THAT THIS NORMAL IS DIRECTED OUTWARDS

#first fundamental form: b(z)[i,j] = b_{ij}_{al-izzi2020shear}
def b(omega):
    return as_tensor((normal(omega))[k] * (e(omega)[i, k]).dx(j), (i,j))

#two-covariant metric tensor: g_{ij}
def g(omega):
    return as_tensor([[1+ (omega[0])**2, (omega[0])*(omega[1])],[(omega[0])*(omega[1]), 1+ (omega[1])**2]])

#two-contravariant metric tensor: g^{ij}
def g_c(omega):
    return ufl.inv(g(omega))

#determinant of the two-covariant metric tensor
def detg(omega):
    return ufl.det(g(omega))

#absolute value of the two-covariant metric tensor
def abs_detg(omega):
    return np.abs(ufl.det(g(omega)))

#square root of the determinant of the two-covariant metric tensor
def sqrt_detg(omega):
    return sqrt(detg(omega))

#square root of the absolute value of the two-covariant metric tensor
def sqrt_abs_detg(omega):
    return sqrt(abs_detg(omega))

#mean curvature, H = H_{al-izzi2020shear}
def H(omega):
    return (0.5 * g_c(omega)[i, j]*b(omega)[j, i])

#same as H(omega), but expressed in terms of the covariant derivative of omega
def H_Nabla_omega(omega):
    return (1.0/2.0 * sqrt_detg(omega) * g_c(omega)[i, j]* Nabla_f(omega, omega)[j, i])

#gaussian curvature: K = K_{al-izzi2020shear}
def K(omega):
    return(ufl.det(as_tensor(b(omega)[i,k]*g_c(omega)[k,j], (i, j))))

#Christoffel symbols of the second kind related to g: Gamma(omega)[i,j,k] = {\Gamma^i_{jk}}_{al-izzi2020shear}
def Gamma(omega):
    return as_tensor(0.5 * g_c(omega)[i,l] * ( (g(omega)[l, k]).dx(j) + (g(omega)[j, l]).dx(k) - (g(omega)[j, k]).dx(l) ), (i, j, k))

#covariant derivative of vector v with respect to \partial/partial x and with respect to the Levi-Civita connection generated by g: Nabla_v(v, omega)[i, j] = {\Nabla_j v^i}_{al-izzi2020shear}
def Nabla_v(u, omega):
    return as_tensor((u[i]).dx(j) + u[k] * Gamma(omega)[i, k, j], (i, j))

#covariant derivative of one-form f with respect to \partial/partial x and with respect to the Levi-Civita connection generated by g: Nabla_f(f, omega)[i, j] = {\Nabla_j f_i}_{al-izzi2020shear}
def Nabla_f(f, omega):
    return as_tensor((f[i]).dx(j) - f[k] * Gamma(omega)[k, i, j], (i, j))

#covariant derivative of a two-coavariant tensor t: Nabla_ff(t, omega)[i, j, k] = \Nabla_k t_{ij}
def Nabla_ff(t, omega):
    return as_tensor((t[i, j]).dx(k) - t[l, j] * Gamma(omega)[l, i, k] - t[i, l] * Gamma(omega)[l, j, k], (i, j, k))

#lalplace-beltrami operator applied to a scalar function f : Nabla_LB(f, omega) = \Nabla_{LB} f_notes
def Nabla_LB(f, omega):
    return (- 1.0/sqrt_detg(omega) * ( ( sqrt_detg(omega) * g_c(omega)[i, j] * (f.dx(j)) ).dx(i) ) )

#2-covariant rate-of_deformation tensor for zero normal velocity: d(u, z)[i, j] = {d_{ij}}_{alizzi2020shear for zero w}
def d(v, w, omega):
    return as_tensor( 0.5 * (g(omega)[i, k] * Nabla_v(v, omega)[k, j] + g(omega)[j, k] * Nabla_v(v, omega)[k, i]) - (b(omega)[i,j]) * w, (i, j) )

#2-contravariant rate-of_deformation tensor: d_c(u, un, z)[i, j] = {d^{ij}}_{alizzi2020shear}
def d_c(v, w, omega):
    return as_tensor( g_c(omega)[i, k] * g_c(omega)[j, l] * d(v, w, omega)[k,l], (i, j) )

#given a vector and a scalar, return the vector vector^i * scalar
def vector_times_scalar(vector, scalar):
    return as_tensor(scalar * vector[i], (i))

# vector living in the three-dimensional Euclidean space, which is orthogonal to the circle of radius r centered at c_r. N3d_c_r[k] = \vec{N}_{\gamma k}_notes
def N3d_c_r(mesh, c_r):
    x = ufl.SpatialCoordinate( mesh )
    norm = sqrt((x[0] - c_r[0])**2 + (x[1] - c_r[1])**2)
    return as_tensor( [(x[0] - c_r[0]) / norm, (x[1] - c_r[1]) / norm, 0.0] )

# Nt_c_r[i] = N_{t \gamma}^i_notes
def Nt_c_r(mesh, c_r, omega):
    return as_tensor(g_c(omega)[i, j] * N3d_c_r(mesh, c_r)[k] * e(omega)[j, k], (i))

#n_c_r[i] = n_\gamma^i_notes
def n_c_r(mesh, c_r, omega):
    return as_tensor((Nt_c_r(mesh, c_r, omega))[k] / sqrt(g(omega)[i, j]* (Nt_c_r(mesh, c_r, omega))[i] *  (Nt_c_r(mesh, c_r, omega))[j] ), (k))

def f_to_v(f, omega):
    return as_tensor(g_c(omega)[i, j] * f[j], (i))

def v_to_f(v, omega):
    return as_tensor(g(omega)[i, j] * v[j], (i))

'''
this method transforms a vector in the tangent bundle of \Omega to the correspoding vector in the 3d Euclidean space in which \Omega is embedded
Input values:
- 'omega': a one-form omega_i, the gradient of z
- 'v' : the  vector v^i to be transformed
Output values:
- the vector in 3d space (a tuple of 3 coordinates)
'''
def from_tangent_to_3D_space(omega, v):
    return as_tensor(v[i]*e(omega)[i, j], (j) )

'''
this method takes as input a vector in the in the 3d Euclidean space and
returns its decomposition in compoennts in the tangent bundle of \Omega and in the component normal ot \Omega
Input values:
- 'omega': a one-form omega_i, the gradient of z
- 'v' : the vector in 3d space (a tuple of 3 coordinates)
Return values:
- the tangential part V_t^i and the normal part V_n
'''
def from_3D_to_tangent_space(omega, V):
    return as_tensor(g_c(omega)[i, j] * V[k] * e(omega)[j, k], (i)), (V[l] * normal(omega)[l])
