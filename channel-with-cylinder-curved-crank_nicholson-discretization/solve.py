"""
This code solves for the dynamics of the Navier Stokes equations on a fixed, curved manifold with Crank Nicholson discretization scheme
It uses the mesh generated by mesh/generate_mesh.py

run with:
clear; clear; rm -r solution; mkdir solution; python3 solve.py [path where to read the mesh] [path where to store the solution] T N
clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/$SOLUTION_PATH/snapshots/csv/nodal_values; python3 solve.py /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/mesh/solution /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/$SOLUTION_PATH  0.001 2

The solution files will be stored in $SOLUTION_PATH


Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE
"""

import colorama as col
from fenics import *
from mshr import *

import sys

# add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append( module_path )

import function_spaces as fsp
import input_output as io
import runtime_arguments as rarg
import print_out_solution as pr_sol

# import variational_problem_bc_obstacle as vp
# import print_out_bc_obstacle as pr_bc
# import read_mesh_bc_obstacle as rmsh

import variational_problem_bc_no_obstacle as vp
import print_out_bc_no_obstacle as pr_bc
import read_mesh_bc_no_obstacle as rmsh

dolfin.parameters["form_compiler"]["quadrature_degree"] = 10

print( "Input directory", rarg.args.input_directory )
print( "Output directory", rarg.args.output_directory )
print( f"Radius of mesh cell = {col.Fore.CYAN}{rmsh.r_mesh:.{io.number_of_decimals}e}{col.Style.RESET_ALL}" )

print( "L = ", rmsh.L )
print( "h = ", rmsh.h )
print( "mu = ", vp.mu )
print( "T = ", vp.T )
print( "N = ", vp.num_steps )

# set the initial profiles
fsp.v_n_1.interpolate( vp.TangentVelocityExpression( element=fsp.Q_v.ufl_element() ) )
fsp.v_n_2.assign( fsp.v_n_1 )
fsp.w.interpolate( vp.NormalVelocityExpression( element=fsp.Q.ufl_element() ) )
fsp.sigma_n_12.interpolate( vp.SurfaceTensionExpression( element=fsp.Q.ufl_element() ) )
fsp.sigma_n_32.assign( fsp.sigma_n_12 )
fsp.z.interpolate( vp.ManifoldExpression( element=fsp.Q_z.ufl_element() ) )
fsp.omega.interpolate( vp.OmegaExpression( element=fsp.Q_omega.ufl_element() ) )

pr_sol.print_z_omega()

print( "Starting time iteration ...", flush=True )
# Time-stepping
t = 0
step = 0
for n in range( vp.num_steps ):
    # Update current time
    t += vp.dt
    step += 1

    # import variational_problem_bc_obstacle
    import variational_problem_bc_no_obstacle

    # step 1
    J1 = derivative( vp.F1, fsp.v_, fsp.J_v_ )
    problem1 = NonlinearVariationalProblem( vp.F1, fsp.v_, vp.bc_v_, J1 )
    solver1 = NonlinearVariationalSolver( problem1 )
    solver1.solve()

    # Step 2: surface_tension correction step
    J2 = derivative( vp.F2, fsp.phi, fsp.J_phi )
    problem2 = NonlinearVariationalProblem( vp.F2, fsp.phi, vp.bc_phi, J2 )
    solver2 = NonlinearVariationalSolver( problem2 )
    solver2.solve()

    # step 3
    J3 = derivative( vp.F3, fsp.v_n, fsp.J_v_n )
    problem3 = NonlinearVariationalProblem( vp.F3, fsp.v_n, [], J3 )
    solver3 = NonlinearVariationalSolver( problem3 )
    solver3.solve()

    pr_bc.print_bcs()

    # obtain fsp.sigma_n from fsp.phi by using the definition of fsp.phi
    fsp.sigma_n_12.assign( fsp.sigma_n_32 - fsp.phi )

    # Update previous solution
    fsp.v_n_2.assign( fsp.v_n_1 )
    fsp.v_n_1.assign( fsp.v_n )

    fsp.sigma_n_32.assign( fsp.sigma_n_12 )

    pr_sol.print_solution( t, step, vp.dt )

    print( "\t%.2f %%" % (100.0 * (t / vp.T)), flush=True )

print( "... done.", flush=True )
