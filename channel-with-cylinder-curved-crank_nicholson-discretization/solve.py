"""
This code solves for the dynamics of the Navier Stokes equations on a fixed, curved manifold with Crank Nicholson discretization scheme
It uses the mesh generated by mesh/generate_mesh.py

run with:
clear; clear; rm -r solution; mkdir solution; python3 solve.py [path where to read the mesh] [path where to store the solution] T N
clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/$SOLUTION_PATH/snapshots/csv/nodal_values; python3 solve.py /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/mesh/solution /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/$SOLUTION_PATH  0.001 2

The solution files will be stored in $SOLUTION_PATH


Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE

For air flow:

    - rho_3d = 1.293 Kg/m^3
    - mu_3d = 18.5e-6 Pa * s
    thus for a thickness Delta = 1cm
    - rho_2d = rho = 1.293e-2 Kg/m^2
    - mu_3d = mu = 1.85e-7 Kg/s
            The velocity at which R = 1 is v_0 = 1e-4 m/s

    To reproduce air flow with no obstacle (figure 8):
        - select  variational_problem_bc_no_obstacle
        - set L = 20
        - set outflow = 'near(x[0], 20)
        - set
                * rho = 1.293e-2
                * mu = 1.85e-7
                * v0 = 1e-4
                * v_l = 1e2 * v0
        - set v__profile_l = Expression(('4.0*1.5*x[1]*(0.41 - x[1]) / pow(h, 2) * v_l', '0'), degree=2, v_l=v_l, h=rmsh.h)
        - run with
            * clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir $SOLUTION_PATH; python3 generate_mesh_bc_no_obstacle.py 0.1 $SOLUTION_PATH
            * clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/$SOLUTION_PATH/snapshots/csv/nodal_values; python3 solve.py /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/mesh/solution /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/$SOLUTION_PATH 2048 2048

    To reproduce air flow with  obstacle (figure 9):
        - select  variational_problem_bc_obstacle
        - set L = 2.2
        - set c_r = [0.2, h/2, 0]
        - set outflow = 'near(x[0], 2.2)
        - set c_r = [0.2, h/2]
        - set cylinder = 'on_boundary && x[0]>0.1 && x[0]<0.3 && x[1]>0.05 && x[1]<0.41-0.05'
        - set
                * rho = 1.293e-2
                * mu = 1.85e-7
                * v0 = 1e-4
                * v_l = 1e2 * v0
        - set v__profile_l = Expression(('4.0*1.5*x[1]*(0.41 - x[1]) / pow(h, 2) * v_l', '0'), degree=2, v_l=v_l, h=rmsh.h)
        - set
                class ManifoldExpression( UserExpression ):
                    def eval(self, values, x):
                        values[0] = 2 * x[1] * (rmsh.h - x[1]) / rmsh.h**2 * (x[1] - rmsh.h / 24) / rmsh.h
                    def value_shape(self):
                        return (1,)

                class OmegaExpression( UserExpression ):
                    def eval(self, values, x):
                        values[0] = 0
                        values[1] = -((rmsh.h**2) - 50.0*rmsh.h*x[1] + 72.0*((x[1])**2))/(12.0*rmsh.h**3)
                    def value_shape(self):
                        return (2,)
        - run with
            * clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir $SOLUTION_PATH; python3 generate_mesh_bc_obstacle.py 0.05 $SOLUTION_PATH
            * clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/$SOLUTION_PATH/snapshots/csv/nodal_values; python3 solve.py /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/mesh/solution /home/fenics/shared/channel-with-cylinder-curved-crank_nicholson-discretization/$SOLUTION_PATH  128 128
"""


import colorama as col
from fenics import *
from mshr import *

import sys

# add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append( module_path )

import function_spaces as fsp
import input_output as io
import runtime_arguments as rarg
import print_out_solution as pr_sol

# import variational_problem_bc_obstacle as vp
# import print_out_bc_obstacle as pr_bc
# import read_mesh_bc_obstacle as rmsh

import variational_problem_bc_no_obstacle as vp
import print_out_bc_no_obstacle as pr_bc
import read_mesh_bc_no_obstacle as rmsh

dolfin.parameters["form_compiler"]["quadrature_degree"] = 10

print( "Input directory", rarg.args.input_directory )
print( "Output directory", rarg.args.output_directory )
print( f"Radius of mesh cell = {col.Fore.CYAN}{rmsh.r_mesh:.{io.number_of_decimals}e}{col.Style.RESET_ALL}" )

print( "L = ", rmsh.L )
print( "h = ", rmsh.h )
print( "mu = ", vp.mu )
print( "T = ", vp.T )
print( "N = ", vp.num_steps )

# set the initial profiles
fsp.v_n_1.interpolate( vp.TangentVelocityExpression( element=fsp.Q_v.ufl_element() ) )
fsp.v_n_2.assign( fsp.v_n_1 )
fsp.w.interpolate( vp.NormalVelocityExpression( element=fsp.Q.ufl_element() ) )
fsp.sigma_n_12.interpolate( vp.SurfaceTensionExpression( element=fsp.Q.ufl_element() ) )
fsp.sigma_n_32.assign( fsp.sigma_n_12 )
fsp.z.interpolate( vp.ManifoldExpression( element=fsp.Q_z.ufl_element() ) )
fsp.omega.interpolate( vp.OmegaExpression( element=fsp.Q_omega.ufl_element() ) )

pr_sol.print_z_omega()

print( "Starting time iteration ...", flush=True )
# Time-stepping
t = 0
step = 0
for n in range( vp.num_steps ):
    # Update current time
    t += vp.dt
    step += 1

    # import variational_problem_bc_obstacle
    import variational_problem_bc_no_obstacle

    # step 1
    J1 = derivative( vp.F1, fsp.v_, fsp.J_v_ )
    problem1 = NonlinearVariationalProblem( vp.F1, fsp.v_, vp.bc_v_, J1 )
    solver1 = NonlinearVariationalSolver( problem1 )
    solver1.solve()

    # Step 2: surface_tension correction step
    J2 = derivative( vp.F2, fsp.phi, fsp.J_phi )
    problem2 = NonlinearVariationalProblem( vp.F2, fsp.phi, vp.bc_phi, J2 )
    solver2 = NonlinearVariationalSolver( problem2 )
    solver2.solve()

    # step 3
    J3 = derivative( vp.F3, fsp.v_n, fsp.J_v_n )
    problem3 = NonlinearVariationalProblem( vp.F3, fsp.v_n, [], J3 )
    solver3 = NonlinearVariationalSolver( problem3 )
    solver3.solve()

    pr_bc.print_bcs()

    # obtain fsp.sigma_n from fsp.phi by using the definition of fsp.phi
    fsp.sigma_n_12.assign( fsp.sigma_n_32 - fsp.phi )

    # Update previous solution
    fsp.v_n_2.assign( fsp.v_n_1 )
    fsp.v_n_1.assign( fsp.v_n )

    fsp.sigma_n_32.assign( fsp.sigma_n_12 )

    pr_sol.print_solution( t, step, vp.dt )

    print( "\t%.2f %%" % (100.0 * (t / vp.T)), flush=True )

print( "... done.", flush=True )
