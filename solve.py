'''
This file solves for the steady state of a two-dimensional fluid in the presence of tangential flows, with the same boundary conditions as in dynamics-bcs-w

This file needs the mesh files, which can be generated by `finite_elements/mesh/membrane_mesh/generate_mesh.py` with
python3 generate_mesh.py 0.1
and which are stored into finite_elements/mesh/membrane_mesh/

To enter the folder
cd shared/navier_stokes/fenics_example

Run with
clear; python3 solve.py [path where to read the mesh] [path where to store the solution]
clear; clear; rm -r solution; python3 solve.py /home/fenics/shared/mesh /home/fenics/shared/solution
clear; clear; rm -r solution; mpirun -np 6 python3 solve.py /home/fenics/shared/mesh /home/fenics/shared/solution

The solution files will be stored in /home/fenics/shared/navier_stokes/fenics_example/solution

Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE
'''

from __future__ import print_function
from fenics import *
from mshr import *
from read_mesh import  *
from geometry import *
from function_spaces import *
from variational_problem import *

set_log_level( 20 )

print("Input diredtory = ", args.input_directory )
print("Output diredtory = ", args.output_directory )
print("Radius of mesh cell = ", r_mesh)


# # Create mesh
# channel = Rectangle(Point(0, 0), Point(1.0, 1.0))
# cylinder = Circle(Point(0.2, 0.2), 0.05)
# domain = channel - cylinder
# mesh = generate_mesh(domain, 64)

# Create XDMF files for visualization output
xdmffile_v = XDMFFile( (args.output_directory) + '/v.xdmf' )
xdmffile_w = XDMFFile( (args.output_directory) + '/w.xdmf' )
xdmffile_sigma = XDMFFile( (args.output_directory) + '/sigma.xdmf' )
xdmffile_omega = XDMFFile( (args.output_directory) + '/omega.xdmf' )
xdmffile_z = XDMFFile( (args.output_directory) + '/z.xdmf' )

xdmffile_n = XDMFFile( (args.output_directory) + '/n.xdmf' )
xdmffile_n.write( facet_normal_smooth(), 0 )

# Define expressions used in variational forms
kappa = Constant( kappa )
rho = Constant( rho )



# solve the variational problem
J = derivative( F, psi, J_psi )
problem = NonlinearVariationalProblem( F, psi, bcs, J )
solver = NonlinearVariationalSolver( problem )

solver.solve()

# get the solution and write it to file
v_dummy, w_dummy, sigma_dummy, omega_dummy, z_dummy = psi.split( deepcopy=True )

# print solution to file
xdmffile_v.write( v_dummy, 0 )
xdmffile_w.write( w_dummy, 0 )
xdmffile_sigma.write( sigma_dummy, 0 )
xdmffile_omega.write( omega_dummy, 0 )
xdmffile_z.write( z_dummy, 0 )

# write the solutions in .h5 format so it can be read from other codes 
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/v.h5", "w" ).write( v_dummy, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/w.h5", "w" ).write( w_dummy, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/sigma.h5", "w" ).write( sigma_dummy, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/omega.h5", "w" ).write( omega_dummy, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/z.h5", "w" ).write( z_dummy, "/f" )

print( "\int_{\partial \Omega_W U \partial \Omega_O} (n_i v^i)^2 dS = ", \
       assemble( ( (n_tb(omega))[i] * g(omega_dummy)[i, j] * v_dummy[j] ) ** 2 * (ds_t + ds_b) ) \
       + assemble( ( (n_circle(omega))[i] * g(omega_dummy)[i, j] * v_dummy[j] ) ** 2 * ds_circle ) \
       )

print( "\int_{\partial \Omega} (n^i \omega_i - psi )^2 dS = ", \
       assemble( ( ( (n_lr(omega_dummy))[i] * omega_dummy[i] - omega_square ) ) ** 2 * (ds_l + ds_r) ) \
       + assemble( ( ( (n_tb(omega_dummy))[i] * omega_dummy[i] - omega_square ) ) ** 2 * (ds_t + ds_b) ) \
       + assemble( ( ( (n_circle(omega_dummy))[i] * omega_dummy[i] - omega_circle ) ) ** 2 * ds_circle ) \
       )

print( "\int_{\partial \Omega_ou} ( n_i d^{i 1})^2 dS =}", \
       assemble( (d_c( v_dummy, w_dummy, omega_dummy )[i, 0] * g( omega_dummy )[i, j] * (n_lr( omega_dummy ))[j]) ** 2 * ds_r ) \
    )

#