'''
This file solves for the steady state of a two-dimensional fluid in the presence of tangential flows, with the same boundary conditions as in dynamics-bcs-w

This file needs the mesh files, which can be generated by `finite_elements/mesh/membrane_mesh/generate_mesh.py` with
python3 generate_mesh.py 0.1
and which are stored into finite_elements/mesh/membrane_mesh/

To enter the folder
cd shared/navier_stokes/fenics_example

Run with
clear; python3 solve.py [path where to read the mesh] [path where to store the solution]
clear; clear; rm -r solution; python3 solve.py /home/fenics/shared/mesh /home/fenics/shared/solution
clear; clear; rm -r solution; mpirun -np 6 python3 solve.py /home/fenics/shared/mesh /home/fenics/shared/solution

The solution files will be stored in /home/fenics/shared/navier_stokes/fenics_example/solution

Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE
'''

from __future__ import print_function
from fenics import *
from mshr import *
from read_mesh import  *
from geometry import *
from function_spaces import *
from variational_problem_bc_a import *

set_log_level( 20 )
dolfin.parameters["form_compiler"]["quadrature_degree"] = 10

print("Input diredtory = ", args.input_directory )
print("Output diredtory = ", args.output_directory )
print("Radius of mesh cell = ", r_mesh)

# Define expressions used in variational forms
kappa = Constant( kappa )
rho = Constant( rho )

# solve the variational problem
J = derivative( F, psi, J_psi )
problem = NonlinearVariationalProblem( F, psi, bcs, J )
solver = NonlinearVariationalSolver( problem )

'''
#set the solver parameters here
params = {'nonlinear_solver': 'newton',
           'newton_solver':
            {
                'linear_solver'           : 'mumps',
                # 'line_search' : 'bt',
                'absolute_tolerance'      : 1e-6,
                'relative_tolerance'      : 1e-6,
                'maximum_iterations'      : 1000000,
                # 'sign'                    : 'nonnegative',
                'relaxation_parameter'    : 0.95,
                # 'preconditioner'    : 'ilu',
                'lu_solver' :{
                    # 'report' : True,
                     'symmetric' : False
                },
                'krylov_solver' :{
                    'divergence_limit' : 1e0,
                    'absolute_tolerance' : 1e-6,
                    'relative_tolerance' : 1e-6,
                    'nonzero_initial_guess' : True
                }

             }
}
solver.parameters.update(params)
'''

solver.solve()


# Create XDMF files for visualization output
xdmffile_v = XDMFFile( (args.output_directory) + '/v.xdmf' )
xdmffile_w = XDMFFile( (args.output_directory) + '/w.xdmf' )
xdmffile_sigma = XDMFFile( (args.output_directory) + '/sigma.xdmf' )
xdmffile_omega = XDMFFile( (args.output_directory) + '/omega.xdmf' )
xdmffile_z = XDMFFile( (args.output_directory) + '/z.xdmf' )

xdmffile_n = XDMFFile( (args.output_directory) + '/n.xdmf' )
xdmffile_n.write( facet_normal_smooth(), 0 )

# copy the data of the  solution psi into v_output, ..., z_output, which will be allocated or re-allocated here
v_output, w_output, sigma_output, omega_output, z_output = psi.split( deepcopy=True )

# print solution to file
xdmffile_v.write( v_output, 0 )
xdmffile_w.write( w_output, 0 )
xdmffile_sigma.write( sigma_output, 0 )
xdmffile_omega.write( omega_output, 0 )
xdmffile_z.write( z_output, 0 )

# write the solutions in .h5 format so it can be read from other codes
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/v.h5", "w" ).write( v_output, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/w.h5", "w" ).write( w_output, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/sigma.h5", "w" ).write( sigma_output, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/omega.h5", "w" ).write( omega_output, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/z.h5", "w" ).write( z_output, "/f" )

import print_out_bc_a