'''
This file solves for the dynamics of a two-dimensional fluid

This file needs the mesh files, which can be generated by `finite_elements/mesh/generate_mesh.py` with
python3 generate_mesh.py 0.1
and which are stored into finite_elements/mesh/solution

Run with
clear; clear; rm -rf solution; mkdir solution; python3 solve.py [path where to read the mesh] [path where to store the solution] T k r e v N
clear; clear; rm -rf solution; mkdir -p /home/fenics/shared/dynamics/solution/snapshots/csv; python3 solve.py /home/fenics/shared/dynamics/mesh/solution /home/fenics/shared/dynamics/solution  0.001 1.0 1.0 1.0 1.0 2
clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p /home/fenics/shared/dynamics/$SOLUTION_PATH/snapshots/csv; python3 solve.py /home/fenics/shared/dynamics/mesh/solution /home/fenics/shared/dynamics/$SOLUTION_PATH  0.001 1.0 1.0 1.0 1.0 2
clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p /home/fenics/shared/dynamics/$SOLUTION_PATH/snapshots/csv; python3 solve.py /home/fenics/shared/dynamics/mesh/solution /home/fenics/shared/dynamics/$SOLUTION_PATH  0.001 0.03 1.0 0.01 100.0 2
clear; clear; rm -rf solution; mkdir -p /home/fenics/shared/dynamics/solution/snapshots/csv; mpirun -np 6 python3 solve.py /home/fenics/shared/dynamics/mesh/solution /home/fenics/shared/dynamics/solution  0.001 1.0 1.0 1.0 1.0 32
time apptainer exec  /mnt/beegfs/common/containers/singularity/dev/FEniCS/FEniCS.sif python3 solve.py $MESH $SOLUTION $T $k $r $e $v $N

The solution files will be stored in /home/fenics/shared/dynamics/solution

Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE
'''

import colorama as col
from fenics import *
from mshr import *

import sys

#add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append(module_path)


import function_spaces as fsp
import input_output as io
# import print_out_bc_a as prout
import print_out_bc_b as prout
import read_mesh as rmsh
import runtime_arguments as rarg
# import variational_problem_bc_a as vp
import variational_problem_bc_b as vp

set_log_level(20)
dolfin.parameters["form_compiler"]["quadrature_degree"] = 10

print("Input diredtory = ", rarg.args.input_directory)
print("Output diredtory = ", rarg.args.output_directory)
print(f"Radius of mesh cell = {col.Fore.CYAN}{rmsh.r_mesh:.{io.number_of_decimals}e}{col.Style.RESET_ALL}")


print("T = ", vp.T)
print("kappa = ", vp.kappa)
print("rho = ", vp.rho)
print("eta = ", vp.eta)
print("v = ", vp.v_bar_l_const)
print("N = ", vp.N)


#Option 1: set initial profiles
#
fsp.v_n_1.interpolate(vp.TangentVelocityExpression(element=fsp.Q_v_n.ufl_element()))
fsp.v_n_2.assign(fsp.v_n_1)
fsp.w_n_1.interpolate(vp.NormalVelocityExpression(element=fsp.Q_w_n.ufl_element()))
fsp.sigma_n_32.interpolate( vp.SurfaceTensionExpression( element=fsp.Q_phi.ufl_element() ))
fsp.z_n_32.interpolate( vp.ManifoldExpression( element=fsp.Q_z_n.ufl_element() ) )
# omega_n_32.interpolate( vp.OmegaExpression( element=fsp.Q_omega_n.ufl_element() ))
#

#Option 2:read initial profiles by reading them from file
'''
read_step = 400
print("Reading initial condition from file ... ")
HDF5File( MPI.comm_world, "solution/snapshots/h5/v_n_" + str( read_step-1 ) + ".h5", "r" ).read(fsp.v_n_1, "/f" )
HDF5File( MPI.comm_world, "solution/snapshots/h5/v_n_" + str( read_step-2 ) + ".h5", "r" ).read(fsp.v_n_2, "/f" )
HDF5File( MPI.comm_world, "solution/snapshots/h5/w_n_" + str( read_step-1 ) + ".h5", "r" ).read(fsp.w_n_1, "/f" )
HDF5File( MPI.comm_world, "solution/snapshots/h5/sigma_n_12_" + str( read_step-1 ) + ".h5", "r" ).read(fsp.sigma_n_32, "/f" )
HDF5File( MPI.comm_world, "solution/snapshots/h5/z_n_12_" + str( read_step-1 ) + ".h5", "r" ).read(fsp.z_n_32, "/f" )
HDF5File( MPI.comm_world, "solution/snapshots/h5/omega_n_12_" + str( read_step-1 ) + ".h5", "r" ).read(fsp.omega_n_32, "/f" )
HDF5File( MPI.comm_world, "solution/snapshots/h5/mu_n_12_" + str( read_step-1 ) + ".h5", "r" ).read(fsp.mu_n_32, "/f" )
print("... done.")
'''



# Time-stepping
t = 0
for step in range(vp.N):

    print("\n* step = ", step, "\n")

    # Update current time
    t += vp.dt

    # import variational_problem_bc_a
    import variational_problem_bc_b

    # solve the variational problem
    J = derivative( vp.F, fsp.psi, fsp.J_psi )
    problem = NonlinearVariationalProblem( vp.F, fsp.psi, vp.bcs, J )
    solver = NonlinearVariationalSolver( problem )

    # the post-processing ('pp') variational problem used to compute tau, ...
    J_pp_nu = derivative( vp.F_pp_nu, fsp.nu_n_12, fsp.J_pp_nu )
    J_pp_tau = derivative( vp.F_pp_tau, fsp.tau_n_12, fsp.J_pp_tau )
    J_pp_d = derivative( vp.F_pp_d, fsp.d, fsp.J_pp_d )
    problem_pp_nu = NonlinearVariationalProblem( vp.F_pp_nu, fsp.nu_n_12, [], J_pp_nu )
    problem_pp_tau = NonlinearVariationalProblem( vp.F_pp_tau, fsp.tau_n_12, [], J_pp_tau )
    problem_pp_d = NonlinearVariationalProblem( vp.F_pp_d, fsp.d, [], J_pp_d )
    solver_pp_nu = NonlinearVariationalSolver( problem_pp_nu )
    solver_pp_tau = NonlinearVariationalSolver( problem_pp_tau )
    solver_pp_d = NonlinearVariationalSolver( problem_pp_d )

    #set the solver parameters here
    # params = {'nonlinear_solver': 'newton',
    #            'newton_solver':
    #             {
    #                 'linear_solver'           : 'mumps',
    #                 # 'line_search' : 'bt',
    #                 'absolute_tolerance'      : 1e-6,
    #                 'relative_tolerance'      : 1e-6,
    #                 'maximum_iterations'      : 1000000,
    #                 # 'sign'                    : 'nonnegative',
    #                 'relaxation_parameter'    : 0.95,
    #                 # 'preconditioner'    : 'ilu',
    #                 'lu_solver' :{
    #                     # 'report' : True,
    #                      'symmetric' : False
    #                 },
    #                 'krylov_solver' :{
    #                     'divergence_limit' : 1e0,
    #                     'absolute_tolerance' : 1e-6,
    #                     'relative_tolerance' : 1e-6,
    #                     'nonzero_initial_guess' : True
    #                 }
    # 
    #              }
    # }
    # solver.parameters.update(params)
    
    solver.solve()

    solver_pp_nu.solve()
    solver_pp_tau.solve()
    solver_pp_d.solve()

    #update previous solution:
    #get the solution and write it to file
    v_bar_output, w_bar_output, phi_output, v_n_output, w_n_output, z_n_12_output, omega_n_12_output, mu_n_12_output = fsp.psi.split( deepcopy=True )

    prout.print_bcs( fsp.psi )
    prout.print_solution( fsp.psi, step, t )


    fsp.v_n_2.assign(fsp.v_n_1)
    fsp.v_n_1.assign( v_n_output )

    fsp.w_n_1.assign( w_n_output )

    fsp.sigma_n_12.assign( fsp.sigma_n_32 - project( phi_output, fsp.Q_phi ) )
    fsp.sigma_n_32.assign(fsp.sigma_n_12)

    fsp.z_n_32.assign( z_n_12_output )



prout.csvfile_bcs.close()
prout.csvfile_F.close()