'''
This file solves for the steady state of a two-dimensional fluid with no flows

This file needs the mesh files, which can be generated by `finite_elements/mesh/generate_square_mesh.py` or ``finite_elements/mesh/membrane_mesh/generate_ring_mesh.py`` with
python3 generate_square_mesh.py 0.1
python3 generate_ring_mesh.py 0.1
and which are stored into finite_elements/mesh

Run with
clear; python3 solve.py [path where to read the mesh] [path where to store the solution]
clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p $SOLUTION_PATH/nodal_values; python3 solve.py /home/fenics/shared/steady-state-no-flow/mesh/solution /home/fenics/shared/steady-state-no-flow/$SOLUTION_PATH
clear; clear; rm -r solution; python3 solve.py /home/fenics/shared/steady-state-no-flow/mesh /home/fenics/shared/steady-state-no-flow/solution
clear; clear; rm -r solution; mpirun -np 6 python3 solve.py /home/fenics/shared/steady-state-no-flow/mesh /home/fenics/shared/steady-state-no-flow/solution

The solution files will be stored in /home/fenics/shared/steady-state-no-flow/solution

Note that all sections of the code which need to be changed when an external parameter (e.g. the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE

All sections of the code where one needs to switch to change mesh geometry or boundary conditions are marked with
# CHANGE VARIATIONAL PROBLEM OR MESH HERE
'''

import colorama as col
from fenics import *
from mshr import *
import sys




#add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append(module_path)

import function_spaces as fsp
import runtime_arguments as rarg

# CHANGE VARIATIONAL PROBLEM OR MESH HERE
# import read_mesh_ring as rmsh
# import read_mesh_square_no_circle as rmsh
import read_mesh_square as rmsh

# CHANGE VARIATIONAL PROBLEM OR MESH HERE
# import variational_problem_bc_ring as vp
# import variational_problem_bc_square_no_circle_a as vp
import variational_problem_bc_square_a as vp
# import variational_problem_bc_square_b as vp


set_log_level( 20 )
dolfin.parameters["form_compiler"]["quadrature_degree"] = 4

print("Input diredtory = ", rarg.args.input_directory )
print("Output diredtory = ", rarg.args.output_directory )
print(f"Radius of mesh cell = {col.Fore.CYAN}{rmsh.r_mesh}{col.Style.RESET_ALL}")


# solve the variational problem
J = derivative( vp.F, fsp.psi, fsp.J_psi )
problem = NonlinearVariationalProblem( vp.F, fsp.psi, vp.bcs, J )
solver = NonlinearVariationalSolver( problem )

#set the solver parameters here
params = {'nonlinear_solver': 'newton',
           'newton_solver':
            {
                'linear_solver'           : 'superlu',
                # 'linear_solver'           : 'mumps',
                # 'linear_solver':   'lu',
                'absolute_tolerance'      : 1e-6,
                'relative_tolerance'      : 1e-6,
                'maximum_iterations'      : 1000000,
                'relaxation_parameter'    : 0.95,
             }
}
solver.parameters.update(params)

#the post-processing ('pp') variational problem used to compute tau
J_pp_nu = derivative( vp.F_pp_nu, fsp.nu, fsp.J_pp_nu )
J_pp_tau = derivative( vp.F_pp_tau, fsp.tau, fsp.J_pp_tau )
problem_pp_nu = NonlinearVariationalProblem( vp.F_pp_nu, fsp.nu, [], J_pp_nu )
problem_pp_tau = NonlinearVariationalProblem( vp.F_pp_tau, fsp.tau, [], J_pp_tau )
solver_pp_nu = NonlinearVariationalSolver( problem_pp_nu )
solver_pp_tau = NonlinearVariationalSolver( problem_pp_tau )


solver.solve()
solver_pp_nu.solve()
solver_pp_tau.solve()

# CHANGE VARIATIONAL PROBLEM OR MESH HERE
# import print_out_bc_ring
# import print_out_bc_square_no_circle_a
import print_out_bc_square_a
# import print_out_bc_square_b
