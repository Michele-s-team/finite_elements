'''
This file solves for the steady state of a two-dimensional fluid with no flows

This file needs the mesh files, which can be generated by `finite_elements/mesh/generate_square_mesh.py` or ``finite_elements/mesh/membrane_mesh/generate_ring_mesh.py`` with
python3 generate_square_mesh.py 0.1
python3 generate_ring_mesh.py 0.1
and which are stored into finite_elements/mesh

Run with
clear; python3 solve.py [path where to read the mesh] [path where to store the solution]
clear; clear; rm -r solution; python3 solve.py /home/fenics/shared/steady-state-no-flow/mesh /home/fenics/shared/steady-state-no-flow/solution
clear; clear; rm -r solution; mpirun -np 6 python3 solve.py /home/fenics/shared/steady-state-no-flow/mesh /home/fenics/shared/steady-state-no-flow/solution

The solution files will be stored in /home/fenics/shared/steady-state-no-flow/solution

Note that all sections of the code which need to be changed when an external parameter (e.g. the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE
'''

from fenics import *
from mshr import *
import sys

#add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append(module_path)

import function_spaces as fsp
import input_output as io
import physics as phys
import read_mesh_ring as rmsh
import runtime_arguments as rarg
#import variational_problem_bc_square_a as vp
# import variational_problem_bc_ring as vp
import variational_problem_bc_square_no_circle_a as vp

set_log_level( 20 )
dolfin.parameters["form_compiler"]["quadrature_degree"] = 10

print("Input diredtory = ", rarg.args.input_directory )
print("Output diredtory = ", rarg.args.output_directory )
print("Radius of mesh cell = ", rmsh.r_mesh)

# Define expressions used in variational forms
kappa = Constant( vp.kappa )

# solve the variational problem
J = derivative( vp.F, fsp.psi, fsp.J_psi )
problem = NonlinearVariationalProblem( vp.F, fsp.psi, vp.bcs, J )
solver = NonlinearVariationalSolver( problem )


#set the solver parameters here
params = {'nonlinear_solver': 'newton',
           'newton_solver':
            {
                # 'linear_solver'           : 'superlu',
                'linear_solver'           : 'mumps',
                'absolute_tolerance'      : 1e-6,
                'relative_tolerance'      : 1e-6,
                'maximum_iterations'      : 1000000,
                'relaxation_parameter'    : 0.95,
             }
}
solver.parameters.update(params)

'''
#set the solver parameters here
params ={"newton_solver": {"linear_solver": 'superlu'}}
solver.parameters.update(params)
'''

solver.solve()


# Create XDMF files for visualization output
xdmffile_z = XDMFFile( (rarg.args.output_directory) + '/z.xdmf' )
xdmffile_omega = XDMFFile( (rarg.args.output_directory) + '/omega.xdmf' )
xdmffile_mu = XDMFFile( (rarg.args.output_directory) + '/mu.xdmf' )
xdmffile_nu = XDMFFile( (rarg.args.output_directory) + '/nu.xdmf' )
xdmffile_tau = XDMFFile( (rarg.args.output_directory) + '/tau.xdmf' )

xdmffile_sigma = XDMFFile( (rarg.args.output_directory) + '/sigma.xdmf' )

xdmffile_n = XDMFFile( (rarg.args.output_directory) + '/n.xdmf' )
xdmffile_n.write( rmsh.facet_normal_smooth(), 0 )

xdmffile_f = XDMFFile( (rarg.args.output_directory) + '/f.xdmf' )
xdmffile_f.parameters.update( {"functions_share_mesh": True, "rewrite_function_mesh": False} )

# copy the data of the  solution psi into v_output, ..., z_output, which will be allocated or re-allocated here
z_output, omega_output, mu_output, nu_output, tau_output = fsp.psi.split( deepcopy=True )

# print solution to file
xdmffile_z.write( z_output, 0 )
xdmffile_omega.write( omega_output, 0 )
xdmffile_mu.write( mu_output, 0 )
xdmffile_nu.write( nu_output, 0 )
xdmffile_tau.write( tau_output, 0 )

xdmffile_sigma.write( fsp.sigma, 0 )

io.print_scalar_to_csvfile(z_output, (rarg.args.output_directory) + '/z.csv')
io.print_vector_to_csvfile(omega_output, (rarg.args.output_directory) + '/omega.csv')
io.print_scalar_to_csvfile(mu_output, (rarg.args.output_directory) + '/mu.csv')
io.print_vector_to_csvfile(nu_output, (rarg.args.output_directory) + '/nu.csv')
io.print_vector_to_csvfile(tau_output, (rarg.args.output_directory) + '/tau.csv')

io.print_scalar_to_csvfile(fsp.sigma, (rarg.args.output_directory) + '/sigma.csv')


# write the solutions in .h5 format so it can be read from other codes
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/z.h5", "w" ).write( z_output, "/f" )
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/omega.h5", "w" ).write( omega_output, "/f" )
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/mu.h5", "w" ).write( mu_output, "/f" )
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/nu.h5", "w" ).write( nu_output, "/f" )
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/tau.h5", "w" ).write( tau_output, "/f" )

HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/sigma.h5", "w" ).write( fsp.sigma, "/f" )

xdmffile_f.write( project(phys.fel_n( omega_output, mu_output, tau_output, kappa ), fsp.Q_sigma), 0 )
xdmffile_f.write( project(phys.flaplace( fsp.sigma, omega_output), fsp.Q_sigma), 0 )
# xdmffile_f.write( project(fvisc_n( v, w, omega_output, eta ), Q_omega), 0 )


# import print_out_bc_square_a
# import print_out_bc_ring
import print_out_bc_square_no_circle_a