'''
This file solves for the steady state of a two-dimensional fluid in the presence of tangential flows

This file needs the mesh files, which can be generated by `/home/fenics/shared/steady-state-flow/mesh/generate_square_mesh.py` or `/home/fenics/shared/steady-state-flow/mesh/generate_ring_mesh.py`` with
python3 generate_square_mesh.py 0.1
python3 generate_ring_mesh.py 0.1
and which are stored into /home/fenics/shared/steady-state-flow/mesh

Run with
clear; python3 solve.py [path where to read the mesh] [path where to store the solution]

example:
clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p $SOLUTION_PATH/nodal_values; python3 solve.py /home/fenics/shared/steady-state-flow/mesh/solution /home/fenics/shared/steady-state-flow/$SOLUTION_PATH
clear; clear; rm -rf solution; python3 solve.py /home/fenics/shared/steady-state-flow/mesh/solution /home/fenics/shared/steady-state-flow/solution
clear; clear; rm -rf solution; mpirun -np 6 python3 solve.py /home/fenics/shared/steady-state-flow/mesh/solution /home/fenics/shared/steady-state-flow/solution

The solution files will be stored in /home/fenics/shared/steady-state-flow/solution

Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE

All sections of the code where one needs to switch to change mesh geometry or boundary conditions are marked with
# CHANGE VARIATIONAL PROBLEM OR MESH HERE
'''

'''
to make figure-4: 
- select bc_square_a
- set everywhere
    L = 1
    h = 1
    r = 0.01
    c_r = [L/2, h/2]
- set in read_mesh_square.py:
    ds_l = Measure( "ds", domain=bgeo.mesh, subdomain_data=mf, subdomain_id=4 )
    ds_r = Measure( "ds", domain=bgeo.mesh, subdomain_data=mf, subdomain_id=2 )
    ds_t = Measure( "ds", domain=bgeo.mesh, subdomain_data=mf, subdomain_id=3 )
    ds_b = Measure( "ds", domain=bgeo.mesh, subdomain_data=mf, subdomain_id=1 )
    ds_circle = Measure( "ds", domain=bgeo.mesh, subdomain_data=mf, subdomain_id=5 )
- set
    v_l_const = 10.0
    w_boundary_const = 0.0
    sigma_r_const = 1.0
    z_circle_const = 0.0
    z_square_const = 0.0
    omega_circle_const = -0.1
    omega_square_const = 0.0
    #bending rigidity
    kappa = 3e-2
    #density
    rho = 1e-12
    #viscosity
    eta = 1e-2
#Nitche's parameter
- set the natural BC in F_v
    [...]
    - 2.0 * eta * ( \
              (geo.d_c( fsp.v, fsp.w, fsp.omega )[i, j] * geo.g( fsp.omega )[i, k] * (bgeo.n_lr( fsp.omega ))[k] * fsp.nu_v[j]) * bgeo.sqrt_deth_lr( fsp.omega ) * rmsh.ds_l \
              # natural BC implemented here
              + (- 1.0/(2.0 * eta) * (bgeo.n_lr( fsp.omega ))[i] * geo.g_c(fsp.omega)[i, 0] * sigma_r * fsp.nu_v[0]) * bgeo.sqrt_deth_lr( fsp.omega ) * rmsh.ds_r \
              + (geo.d_c( fsp.v, fsp.w, fsp.omega )[i, 1] * geo.g( fsp.omega )[i, k] * (bgeo.n_lr( fsp.omega ))[k] * fsp.nu_v[1]) * bgeo.sqrt_deth_lr( fsp.omega ) * rmsh.ds_r \
              + (geo.d_c( fsp.v, fsp.w, fsp.omega )[i, j] * geo.g( fsp.omega )[i, k] * (bgeo.n_tb( fsp.omega ))[k] * fsp.nu_v[j]) * bgeo.sqrt_deth_tb( fsp.omega ) * rmsh.ds_tb \
              + (geo.d_c( fsp.v, fsp.w, fsp.omega )[i, j] * geo.g( fsp.omega )[i, k] * (bgeo.n_circle( fsp.omega ))[k] * fsp.nu_v[j]) * bgeo.sqrt_deth_circle( fsp.omega, rmsh.c_r ) * (1.0 / rmsh.r) * rmsh.ds_circle
    )
- generate the mesh with finite_elements/generate-mesh/2d/symmetric-square-circle/circles/generate_mesh.py with
    clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir $SOLUTION_PATH; python3 generate_mesh.py 0.1 32 12 $SOLUTION_PATH
- run with 
     clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p $SOLUTION_PATH/nodal_values; python3 solve.py /home/fenics/shared/generate-mesh/2d/symmetric-square-circle/circles/solution/ /home/fenics/shared/steady-state-flow/$SOLUTION_PATH
    
'''

import colorama as col
from fenics import *
from mshr import *

import sys

#add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append(module_path)

import function_spaces as fsp
import input_output as io
import runtime_arguments as rarg

# CHANGE VARIATIONAL PROBLEM OR MESH HERE
# import read_mesh_ring as rmsh
import read_mesh_square as rmsh

# CHANGE VARIATIONAL PROBLEM OR MESH HERE
# import variational_problem_bc_ring_1 as vp
# import variational_problem_bc_ring_2 as vp
# import variational_problem_bc_square_a as vp
import variational_problem_bc_square_b as vp

set_log_level( 20 )
dolfin.parameters["form_compiler"]["quadrature_degree"] = 10

print("Input diredtory = ", rarg.args.input_directory )
print("Output diredtory = ", rarg.args.output_directory )
print(f"Radius of mesh cell = {col.Fore.CYAN}{rmsh.r_mesh:.{io.number_of_decimals}e}{col.Style.RESET_ALL}")



# solve the variational problem
J = derivative( vp.F, fsp.psi, fsp.J_psi )
problem = NonlinearVariationalProblem( vp.F, fsp.psi, vp.bcs, J )
solver = NonlinearVariationalSolver( problem )


#set the solver parameters here
params = {'nonlinear_solver': 'newton',
           'newton_solver':
            {
                # 'linear_solver'           : 'gmres',
                # 'linear_solver'           : 'minres',
                # 'linear_solver'           : 'petsc',
                # 'linear_solver'           : 'richardson',
                # 'linear_solver'           : 'superlu_dist',
                # 'linear_solver'           : 'tfqmr',
                # 'linear_solver'           : 'umfpack',
                # 'linear_solver'           : 'cg',
                # 'linear_solver'           : 'bicgstab',
                # 'linear_solver'           : 'superlu',
                'linear_solver'           : 'mumps',
                # 'linear_solver'           : 'lu',
                'absolute_tolerance'      : 1e-6,
                'relative_tolerance'      : 1e-6,
                'maximum_iterations'      : 1000000,
                'relaxation_parameter'    : 0.95,
             }
}
solver.parameters.update(params)

'''
#set the solver parameters here
params ={"newton_solver": {"linear_solver": 'superlu'}}
solver.parameters.update(params)
'''

#the post-processing ('pp') variational problem used to compute tau
J_pp_nu = derivative( vp.F_pp_nu, fsp.nu, fsp.J_pp_nu )
J_pp_tau = derivative( vp.F_pp_tau, fsp.tau, fsp.J_pp_tau )
J_pp_d = derivative( vp.F_pp_d, fsp.d, fsp.J_pp_d )
problem_pp_nu = NonlinearVariationalProblem( vp.F_pp_nu, fsp.nu, [], J_pp_nu )
problem_pp_tau = NonlinearVariationalProblem( vp.F_pp_tau, fsp.tau, [], J_pp_tau )
problem_pp_d = NonlinearVariationalProblem( vp.F_pp_d, fsp.d, [], J_pp_d )
solver_pp_nu = NonlinearVariationalSolver( problem_pp_nu )
solver_pp_tau = NonlinearVariationalSolver( problem_pp_tau )
solver_pp_d = NonlinearVariationalSolver( problem_pp_d )

solver.solve()
solver_pp_nu.solve()
solver_pp_tau.solve()
solver_pp_d.solve()


# CHANGE VARIATIONAL PROBLEM OR MESH HERE
# import print_out_bc_ring_1
# import print_out_bc_ring_2
# import print_out_bc_square_a
import print_out_bc_square_b
