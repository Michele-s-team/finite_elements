'''
This file solves for the steady state of a two-dimensional fluid in the presence of tangential flows

This file needs the mesh files, which can be generated by `/home/fenics/shared/steady-state-flow/mesh/generate_square_mesh.py` or `/home/fenics/shared/steady-state-flow/mesh/generate_ring_mesh.py`` with
python3 generate_square_mesh.py 0.1
python3 generate_ring_mesh.py 0.1
and which are stored into /home/fenics/shared/steady-state-flow/mesh

Run with
clear; python3 solve.py [path where to read the mesh] [path where to store the solution]

example:
clear; clear; rm -r solution; python3 solve.py /home/fenics/shared/steady-state-flow/mesh /home/fenics/shared/steady-state-flow/solution
clear; clear; rm -r solution; mpirun -np 6 python3 solve.py /home/fenics/shared/steady-state-flow/mesh /home/fenics/shared/steady-state-flow/solution

The solution files will be stored in /home/fenics/shared/steady-state-flow/solution

Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE
'''

import colorama as col
from fenics import *
from mshr import *

import sys

#add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append(module_path)

import function_spaces as fsp
import input_output as io
import physics as phys
import runtime_arguments as rarg

import read_mesh_ring as rmsh

import variational_problem_bc_ring as vp

set_log_level( 20 )
dolfin.parameters["form_compiler"]["quadrature_degree"] = 10

print("Input diredtory = ", rarg.args.input_directory )
print("Output diredtory = ", rarg.args.output_directory )
print(f"Radius of mesh cell = {col.Fore.CYAN}{rmsh.r_mesh}{col.Style.RESET_ALL}")



# solve the variational problem
J = derivative( vp.F, fsp.psi, fsp.J_psi )
problem = NonlinearVariationalProblem( vp.F, fsp.psi, vp.bcs, J )
solver = NonlinearVariationalSolver( problem )

'''
#set the solver parameters here
params = {'nonlinear_solver': 'newton',
           'newton_solver':
            {
                'linear_solver'           : 'mumps',
                # 'line_search' : 'bt',
                'absolute_tolerance'      : 1e-6,
                'relative_tolerance'      : 1e-6,
                'maximum_iterations'      : 1000000,
                # 'sign'                    : 'nonnegative',
                'relaxation_parameter'    : 0.95,
                # 'preconditioner'    : 'ilu',
             }
}
solver.parameters.update(params)
'''
'''
#set the solver parameters here
params ={"newton_solver": {"linear_solver": 'superlu'}}
solver.parameters.update(params)
'''

solver.solve()


# Create XDMF files for visualization output
xdmffile_v = XDMFFile( (rarg.args.output_directory) + '/v.xdmf' )
xdmffile_w = XDMFFile( (rarg.args.output_directory) + '/w.xdmf' )
xdmffile_sigma = XDMFFile( (rarg.args.output_directory) + '/sigma.xdmf' )
xdmffile_omega = XDMFFile( (rarg.args.output_directory) + '/omega.xdmf' )
xdmffile_z = XDMFFile( (rarg.args.output_directory) + '/z.xdmf' )

# copy the data of the  solution psi into v_output, ..., z_output, which will be allocated or re-allocated here
v_output, w_output, sigma_output, z_output, omega_output = fsp.psi.split( deepcopy=True )

# print solution to file
xdmffile_v.write( v_output, 0 )
xdmffile_w.write( w_output, 0 )
xdmffile_z.write( z_output, 0 )
xdmffile_omega.write( omega_output, 0 )

xdmffile_sigma.write( sigma_output, 0 )

io.print_vector_to_csvfile(v_output, (rarg.args.output_directory) + '/v.csv')
io.print_scalar_to_csvfile(w_output, (rarg.args.output_directory) + '/w.csv')
io.print_scalar_to_csvfile(z_output, (rarg.args.output_directory) + '/z.csv')
io.print_vector_to_csvfile(omega_output, (rarg.args.output_directory) + '/omega.csv')



# write the solutions in .h5 format so it can be read from other codes
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/v.h5", "w" ).write( v_output, "/f" )
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/w.h5", "w" ).write( w_output, "/f" )
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/sigma.h5", "w" ).write( sigma_output, "/f" )
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/omega.h5", "w" ).write( omega_output, "/f" )
HDF5File( MPI.comm_world, (rarg.args.output_directory) + "/h5/z.h5", "w" ).write( z_output, "/f" )

import print_out_bc_ring