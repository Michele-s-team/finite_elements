'''
This file solves for the steady state of a two-dimensional fluid in the presence of tangential flows

This file needs the mesh files, which can be generated by `/home/fenics/shared/steady-state-flow/mesh/generate_square_mesh.py` or `/home/fenics/shared/steady-state-flow/mesh/generate_ring_mesh.py`` with
python3 generate_square_mesh.py 0.1
python3 generate_ring_mesh.py 0.1
and which are stored into /home/fenics/shared/steady-state-flow/mesh

Run with
clear; python3 solve.py [path where to read the mesh] [path where to store the solution]

example:
clear; clear; SOLUTION_PATH="solution"; rm -rf $SOLUTION_PATH; mkdir -p $SOLUTION_PATH/nodal_values; python3 solve.py /home/fenics/shared/steady-state-flow/mesh/solution /home/fenics/shared/steady-state-flow/$SOLUTION_PATH
clear; clear; rm -rf solution; python3 solve.py /home/fenics/shared/steady-state-flow/mesh/solution /home/fenics/shared/steady-state-flow/solution
clear; clear; rm -rf solution; mpirun -np 6 python3 solve.py /home/fenics/shared/steady-state-flow/mesh/solution /home/fenics/shared/steady-state-flow/solution

The solution files will be stored in /home/fenics/shared/steady-state-flow/solution

Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE
'''

import colorama as col
from fenics import *
from mshr import *

import sys

#add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append(module_path)

import function_spaces as fsp
import input_output as io
import runtime_arguments as rarg

import read_mesh_ring as rmsh
# import read_mesh_square as rmsh

import variational_problem_bc_ring_1 as vp
# import variational_problem_bc_ring_2 as vp
# import variational_problem_bc_square_a as vp
# import variational_problem_bc_square_b as vp

set_log_level( 20 )
dolfin.parameters["form_compiler"]["quadrature_degree"] = 10

print("Input diredtory = ", rarg.args.input_directory )
print("Output diredtory = ", rarg.args.output_directory )
print(f"Radius of mesh cell = {col.Fore.CYAN}{rmsh.r_mesh:.{io.number_of_decimals}e}{col.Style.RESET_ALL}")



# solve the variational problem
J = derivative( vp.F, fsp.psi, fsp.J_psi )
problem = NonlinearVariationalProblem( vp.F, fsp.psi, vp.bcs, J )
solver = NonlinearVariationalSolver( problem )


#set the solver parameters here
params = {'nonlinear_solver': 'newton',
           'newton_solver':
            {
                # 'linear_solver'           : 'gmres',
                # 'linear_solver'           : 'minres',
                # 'linear_solver'           : 'petsc',
                # 'linear_solver'           : 'richardson',
                # 'linear_solver'           : 'superlu_dist',
                # 'linear_solver'           : 'tfqmr',
                # 'linear_solver'           : 'umfpack',
                # 'linear_solver'           : 'cg',
                # 'linear_solver'           : 'bicgstab',
                # 'linear_solver'           : 'superlu',
                'linear_solver'           : 'mumps',
                # 'linear_solver'           : 'lu',
                'absolute_tolerance'      : 1e-6,
                'relative_tolerance'      : 1e-6,
                'maximum_iterations'      : 1000000,
                'relaxation_parameter'    : 0.95,
             }
}
solver.parameters.update(params)

'''
#set the solver parameters here
params ={"newton_solver": {"linear_solver": 'superlu'}}
solver.parameters.update(params)
'''

#the post-processing ('pp') variational problem used to compute tau
J_pp_nu = derivative( vp.F_pp_nu, fsp.nu, fsp.J_pp_nu )
J_pp_tau = derivative( vp.F_pp_tau, fsp.tau, fsp.J_pp_tau )
J_pp_d = derivative( vp.F_pp_d, fsp.d, fsp.J_pp_d )
problem_pp_nu = NonlinearVariationalProblem( vp.F_pp_nu, fsp.nu, [], J_pp_nu )
problem_pp_tau = NonlinearVariationalProblem( vp.F_pp_tau, fsp.tau, [], J_pp_tau )
problem_pp_d = NonlinearVariationalProblem( vp.F_pp_d, fsp.d, [], J_pp_d )
solver_pp_nu = NonlinearVariationalSolver( problem_pp_nu )
solver_pp_tau = NonlinearVariationalSolver( problem_pp_tau )
solver_pp_d = NonlinearVariationalSolver( problem_pp_d )

solver.solve()
solver_pp_nu.solve()
solver_pp_tau.solve()
solver_pp_d.solve()



import print_out_bc_ring_1
# import print_out_bc_ring_2
# import print_out_bc_square_a
# import print_out_bc_square_b
