'''
This code reads the box generated by 3d/mesh/generate_box.py and creates a square, 2d mesh given by the xz side of the box
run with
clear; clear; python3 submesh.py [path where to find the mesh]
example:
clear; clear; python3 submesh.py /home/fenics/shared/generate-mesh/3d/box/solution
'''


import h5py
from mshr import *
import numpy as np
from dolfin import *
import meshio
import argparse

import sys

#add the path where to find the shared modules
module_path = '/home/fenics/shared/modules'
sys.path.append(module_path)

import mesh as msh


parser = argparse.ArgumentParser()
parser.add_argument("input_directory")
args = parser.parse_args()

#read the mesh of the cube
mesh = Mesh()
xdmf = XDMFFile(mesh.mpi_comm(), (args.input_directory) + "/tetrahedron_mesh.xdmf")
xdmf.read(mesh)

#extract the mesh corresponding to the side of the cube with y = 0 and store it in mesh2D
with XDMFFile("solution/cube_mesh.xdmf") as xdmf:
    xdmf.write(mesh)

dim=3
bdim = dim-1
boundary_mesh = BoundaryMesh( mesh, "exterior" )
mapping = boundary_mesh.entity_map( bdim )
part_of_bot = MeshFunction("size_t", boundary_mesh, bdim )
#run over all cells of boundary_mesh and write `1` in part_of_bot for the cells which have the y component of the facet normal equal to -1 : in this way, one is selecting the cells which belong to the xz side of the box
for cell in cells( boundary_mesh ):
    curr_facet_normal = Facet(mesh, mapping[cell.index()]).normal()
    if near(curr_facet_normal.y(), -1.0):  # On bot boundary
        part_of_bot[cell] = 1

bot_boundary = SubMesh( boundary_mesh, part_of_bot, 1 )
#File('bot_boundary.pvd') << bot_boundary
with XDMFFile("solution/bot_mesh.xdmf") as xdmf:
    xdmf.write(bot_boundary)


in_mesh = meshio.read("solution/bot_mesh.xdmf")

cells = in_mesh.get_cells_type("triangle")
#remove the y component of the points in in_mesh to switch from a 3d to a 2d mesh
points = np.delete(in_mesh.points, 1, axis=1)
out_mesh = meshio.Mesh(points=points, cells={"triangle": cells})
meshio.write("solution/pruned_mesh.xdmf", out_mesh)

#the resulting 2d mesh is written into mesh2D
mesh2D = Mesh()
with XDMFFile("solution/pruned_mesh.xdmf") as xdmf:
    xdmf.read(mesh2D)
print("Dimension of mesh2D = ", mesh2D.geometry().dim())


#test mesh2D by integrating a function over it 
#analytical expression for a  scalar function used to test the ds
class FunctionTestIntegral(UserExpression):
    def eval(self, values, x):
        values[0] = (np.cos(x[0]-x[1]))**2 * (np.sin(x[0]-x[1]))**3
    def value_shape(self):
        return (1,)

#read the tetrahedra
mvc = MeshValueCollection("size_t", mesh2D, mesh2D.topology().dim())
# with XDMFFile("solution/pruned_mesh.xdmf") as infile:
#     infile.read(mvc, "name_to_read")
cf = cpp.mesh.MeshFunctionSizet(mesh2D, mvc)
# xdmf.close()
dv_custom = Measure("dx", domain=mesh2D, subdomain_data=cf)    # Line measure

Q = FunctionSpace( mesh2D, 'P', 1 )
f_test_ds = Function( Q )

# f_test_ds is a scalar function defined on the mesh, that will be used to test whether the boundary elements ds_circle, ds_inflow, ds_outflow, .. are defined correclty . This will be done by computing an integral of f_test_ds over these boundary terms and comparing with the exact result
f_test_ds.interpolate( FunctionTestIntegral( element=Q.ufl_element() ))

#print out the integrals on the surface elements and compare them with the exact values to double check that the elements are tagged correctly
print(f"Volume = {assemble(f_test_ds*dv_custom)}, should be 0.0219446")

msh.test_mesh_integral( 0.0219446, f_test_ds, dv_custom, 'Volume' )
