'''
This file solves for the steady state of a two-dimensional fluid in the presence of tangential flows, with the same boundary conditions as in dynamics-bcs-w

This file needs the mesh files, which can be generated by `finite_elements/mesh/membrane_mesh/generate_mesh.py` with
python3 generate_mesh.py 0.1
and which are stored into finite_elements/mesh/membrane_mesh/

To enter the folder
cd shared/navier_stokes/fenics_example

Run with
clear; python3 example.py [path where to read the mesh] [path where to store the solution]
clear; clear; rm -r solution; python3 example.py /home/fenics/shared/mesh/membrane_mesh /home/fenics/shared/navier_stokes/fenics_example/solution
clear; clear; rm -r solution; mpirun -np 6 python3 example.py /home/fenics/shared/mesh/membrane_mesh /home/fenics/shared/navier_stokes/fenics_example/solution

The solution files will be stored in /home/fenics/shared/navier_stokes/fenics_example/solution

Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
#CHANGE PARAMETERS HERE
'''

from __future__ import print_function
from fenics import *
from mshr import *
from geometry import *

set_log_level( 20 )

print("Input diredtory = ", args.input_directory )
print("Output diredtory = ", args.output_directory )
print("Radius of mesh cell = ", r_mesh)


# # Create mesh
# channel = Rectangle(Point(0, 0), Point(1.0, 1.0))
# cylinder = Circle(Point(0.2, 0.2), 0.05)
# domain = channel - cylinder
# mesh = generate_mesh(domain, 64)

# Create XDMF files for visualization output
xdmffile_v = XDMFFile( (args.output_directory) + '/v.xdmf' )
xdmffile_w = XDMFFile( (args.output_directory) + '/w.xdmf' )
xdmffile_sigma = XDMFFile( (args.output_directory) + '/sigma.xdmf' )
xdmffile_omega = XDMFFile( (args.output_directory) + '/omega.xdmf' )
xdmffile_z = XDMFFile( (args.output_directory) + '/z.xdmf' )

xdmffile_n = XDMFFile( (args.output_directory) + '/n.xdmf' )
xdmffile_n.write( facet_normal_smooth(), 0 )

# read an object with label subdomain_id from xdmf file and assign to it the ds `ds_inner`
mf = dolfin.cpp.mesh.MeshFunctionSizet( mesh, mvc )

# test for surface elements
ds_l = Measure( "ds", domain=mesh, subdomain_data=mf, subdomain_id=2 )
ds_r = Measure( "ds", domain=mesh, subdomain_data=mf, subdomain_id=3 )
ds_t = Measure( "ds", domain=mesh, subdomain_data=mf, subdomain_id=4 )
ds_b = Measure( "ds", domain=mesh, subdomain_data=mf, subdomain_id=5 )
ds_circle = Measure( "ds", domain=mesh, subdomain_data=mf, subdomain_id=6 )
# ds_lr = ds_l + ds_r
# ds_tb = ds_t + ds_b

# f_test_ds is a scalar function defined on the mesh, that will be used to test whether the boundary elements ds_circle, ds_inflow, ds_outflow, .. are defined correclty . This will be done by computing an integral of f_test_ds over these boundary terms and comparing with the exact result 
f_test_ds = Function( Q_z )
f_test_ds.interpolate( FunctionTestIntegralsds( element=Q_z.ufl_element() ) )

# here I integrate \int ds 1 over the circle and store the result of the integral as a double in inner_circumference
integral_l = assemble( f_test_ds * ds_l )
integral_r = assemble( f_test_ds * ds_r )
integral_t = assemble( f_test_ds * ds_t )
integral_b = assemble( f_test_ds * ds_b )
integral_circle = assemble( f_test_ds * ds_circle )


# print out the integrals on the surface elements and compare them with the exact values to double check that the elements are tagged correctly
print( "Integral l = ", integral_l, " exact value = 0.462517" )
print( "Integral r = ", integral_r, " exact value = 0.47113" )
print( "Integral t = ", integral_t, " exact value = 0.498266" )
print( "Integral b = ", integral_b, " exact value = 0.413016" )
print( "Integral circle = ", integral_circle, " exact value = 0.0610826" )

#sign



# Define functions
# the Jacobian
J_psi = TrialFunction( Q )
psi = Function( Q )
nu_v, nu_w, nu_sigma, nu_omega, nu_z = TestFunctions( Q )
# fields at the preceeding steps
# v_n_1 = Function(Q_v_n)
# v_n_2 = Function(Q_v_n)
# w_n_1 = Function(Q_w_n)
# sigma_n_12 = Function( Q_phi )
# sigma_n_32 = Function( Q_phi )
# z_n_32 = Function( Q_z_n )

# v_n_0, ...., z_n_0 are used to store the initial conditions
# sigma_n_12_0 = Function( Q_phi )
v_0 = Function( Q_v )
w_0 = Function( Q_w )
sigma_0 = Function( Q_sigma )
z_0 = Function( Q_z )
omega_0 = Function( Q_omega )

v, w, sigma, omega, z = split( psi )

# Define expressions used in variational forms
kappa = Constant( kappa )
rho = Constant( rho )


# the values of \partial_i z = omega_i on the circle and on the square, to be used in the boundary conditions (BCs) imposed with Nitche's method, in F_N
omega_circle = interpolate( grad_circle_Expression( element=Q_omega.ufl_element() ), Q_omega )
omega_square = interpolate( grad_square_Expression( element=Q_omega.ufl_element() ), Q_omega )

# assigner = FunctionAssigner(Q, [Q_v_bar, Q_w_bar, Q_phi, Q_v_n, Q_w_n, Q_omega_n, Q_z_n])
# assigner.assign(psi, [v_bar_0, w_bar_0, phi_0, v_n_0, w_n_0, omega_n_0, z_n_0])

# CHANGE PARAMETERS HERE
l_profile_v = Expression( ('v_l', '0'), v_l=v_l, element = Q_v.ufl_element() )
# CHANGE PARAMETERS HERE

# boundary conditions (BCs)
# BCs for v_bar
bc_v_l = DirichletBC( Q.sub( 0 ), l_profile_v, boundary_l )

# BCs for w_bar
bc_w_lr = DirichletBC( Q.sub( 1 ), Constant( 0 ), boundary_lr )
bc_w_tb = DirichletBC( Q.sub( 1 ), Constant( 0 ), boundary_tb )
bc_w_circle = DirichletBC( Q.sub( 1 ), Constant( 0 ), boundary_circle )

#BC for sigma
bc_sigma = DirichletBC(Q.sub(2), Constant(0), boundary_r)

# CHANGE PARAMETERS HERE
# BCs for z
bc_z_circle = DirichletBC( Q.sub( 4 ), Expression( '0.0', element=Q.sub( 4 ).ufl_element() ), boundary_circle )
bc_z_square = DirichletBC( Q.sub( 4 ), Expression( '0.0', element=Q.sub( 4 ).ufl_element(), h=h ), boundary_square )
# CHANGE PARAMETERS HERE

# all BCs
bcs = [bc_v_l, bc_w_lr, bc_w_tb, bc_w_circle, bc_sigma, bc_z_circle, bc_z_square]


#set initial profiles
# v_n_1.interpolate(TangentVelocityExpression(element=Q_v_n.ufl_element()))
# v_n_2.assign(v_n_1)
# w_n_1.interpolate(NormalVelocityExpression(element=Q_w_n.ufl_element()))
# sigma_n_32.interpolate( SurfaceTensionExpression( element=Q_phi.ufl_element() ))
# z_n_32.interpolate( ManifoldExpression( element=Q_z_n.ufl_element() ) )
# omega_n_32.interpolate( OmegaExpression( element=Q_omega_n.ufl_element() ))



# Define variational problem : F_v, F_z are related to the PDEs for v, ..., z respectively . F_N enforces the BCs with Nitsche's method.
# To be safe, I explicitly wrote each term on each part of the boundary with its own normal vector and pull-back of the metric: for example, on the left (l) and on the right (r) sides of the rectangle,
# the surface elements are ds_l + ds_r, and the normal is n_lr(omega), and the pull-back of the metric is sqrt_deth_lr: this avoids odd interpolations at the corners of the rectangle edges.


F_sigma = (Nabla_v( v, omega )[i, i] - 2.0 * H( omega ) * w) * nu_sigma * sqrt_detg( omega ) * dx

F_v = ( \
                    rho * ( \
                          (v[j] * Nabla_v( v, omega )[i, j] - 2.0 * v[j] * w * g_c( omega )[i, k] * b( omega )[k, j]) * nu_v[i] \
                          + 1.0 / 2.0 * (w ** 2) * g_c( omega )[i, j] * Nabla_f( nu_v, omega )[i, j] \
                  ) \
                    + (sigma * g_c( omega )[i, j] * Nabla_f( nu_v, omega )[i, j] \
                       + 2.0 * eta * d_c( v, w, omega )[j, i] * Nabla_f( nu_v, omega )[j, i])
      ) * sqrt_detg( omega ) * dx \
      - rho / 2.0 * ( \
                    ((w ** 2) * (n_lr( omega ))[i] * nu_v[i]) * sqrt_deth_lr( omega ) * (ds_l + ds_r) \
                    + ((w ** 2) * (n_tb( omega ))[i] * nu_v[i]) * sqrt_deth_tb( omega ) * (ds_t + ds_b) \
                    + ((w ** 2) * (n_circle( omega ))[i] * nu_v[i]) * sqrt_deth_circle( omega, c_r ) * (1.0 / r) * ds_circle
      ) \
      - ( \
                    (sigma * (n_lr( omega ))[i] * nu_v[i]) * sqrt_deth_lr( omega ) * (ds_l + ds_r) \
                    + (sigma * (n_tb( omega ))[i] * nu_v[i]) * sqrt_deth_tb( omega ) * (ds_t + ds_b) \
                    + (sigma * (n_circle( omega ))[i] * nu_v[i]) * sqrt_deth_circle( omega, c_r ) * (1.0 / r) * ds_circle
      ) \
      - 2.0 * eta * ( \
            # natural bc
              (d_c( v, w, omega )[i, j] * g( omega )[i, k] * (n_lr( omega ))[k] * nu_v[j]) * sqrt_deth_lr( omega ) * ds_l \
              + (d_c( v, w, omega )[i, j] * g( omega )[i, k] * (n_tb( omega ))[k] * nu_v[j]) * sqrt_deth_tb( omega ) * (ds_t + ds_b) \
              + (d_c( v, w, omega )[i, j] * g( omega )[i, k] * (n_circle( omega ))[k] * nu_v[j]) * sqrt_deth_circle( omega, c_r ) * (1.0 / r) * ds_circle
      )

F_w = ( \
                    rho * (v[i] * v[k] * b( omega )[k, i]) * nu_w \
                    - rho * w * Nabla_v( vector_times_scalar( v, nu_w ), omega )[i, i] \
                    + 2.0 * kappa * ( \
                                  - g_c( omega )[i, j] * ((H( omega )).dx( i )) * (nu_w.dx( j )) \
                                  + 2.0 * H( omega ) * ((H( omega )) ** 2 - K( omega )) * nu_w \
                          ) \
                    - ( \
                                  2.0 * sigma * H( omega ) \
                                  + 2.0 * eta * (g_c( omega )[i, k] * Nabla_v( v, omega )[j, k] *
                                                 (b( omega ))[i, j] - 2.0 * w * (2.0 * (H( omega )) ** 2 - K( omega )))
                    ) * nu_w
      ) * sqrt_detg( omega ) * dx \
+ rho * ( \
              (w * nu_w * (n_lr( omega ))[j] * g( omega )[j, i] * v[i]) * sqrt_deth_lr( omega ) * (ds_l + ds_r) \
              + (w * nu_w * (n_tb( omega ))[j] * g( omega )[j, i] * v[i]) * sqrt_deth_tb( omega ) * (ds_t + ds_b) \
              + (w * nu_w * (n_circle( omega ))[j] * g( omega )[j, i] * v[i]) * sqrt_deth_circle( omega, c_r ) * (1.0 / r) * ds_circle
) \
      # sign
+ 2.0 * kappa * ( \
              (nu_w * (n_lr( omega ))[i] * ((H( omega )).dx( i ))) * sqrt_deth_square( omega ) * (ds_l + ds_r) \
              + (nu_w * (n_tb( omega ))[i] * ((H( omega )).dx( i ))) * sqrt_deth_square( omega ) * (ds_t + ds_b) \
              + (nu_w * (n( omega ))[i] * ((H( omega )).dx( i ))) * sqrt_deth_circle( omega, c_r ) * ds_circle
)

'''
F_z = ( \
                  ( \
                              - w * ((normal( omega ))[2] - ((normal( omega ))[0] * omega[0] + (normal( omega ))[1] * omega[1])) \
                      ) * nu_z \
          ) * sqrt_detg( omega ) * dx

F_omega = (z * Nabla_v( nu_omega, omega )[i, i] + omega[i] * nu_omega[i]) * sqrt_detg( omega ) * dx \
          - ( \
                      ((n_lr( omega ))[i] * g( omega )[i, j] * z * nu_omega[j]) * sqrt_deth_square( omega ) * (ds_l + ds_r) \
                      + ((n_tb( omega ))[i] * g( omega )[i, j] * z * nu_omega[j]) * sqrt_deth_square( omega ) * (ds_t + ds_b) \
                      + ((n( omega ))[i] * g( omega )[i, j] * z * nu_omega[j]) * sqrt_deth_circle( omega, c_r ) * ds_circle
          )

F_N = alpha / r_mesh * ( \
            (((n_overline_lr())[i] * omega[i] - (n_overline_lr())[i] * omega_square[i]) * ((n_overline_lr())[k] * g( omega )[k, l] * nu_omega[l])) * sqrt_deth_square( omega ) * (
            ds_l + ds_r) \
            + (((n_overline_tb())[i] * omega[i] - (n_overline_tb())[i] * omega_square[i]) * ((n_overline_tb())[k] * g( omega )[k, l] * nu_omega[l])) * sqrt_deth_square( omega ) * (
                    ds_t + ds_b) \
            + ((facet_normal[i] * omega[i] - facet_normal[i] * omega_circle[i]) * (facet_normal[k] * g( omega )[k, l] * nu_omega[l])) * sqrt_deth_circle( omega, c_r ) * ds_circle \
 \
            + (((n_overline_tb())[i] * v[i] - 0) * ((n_overline_tb())[j] * nu_v[j])) * sqrt_deth_square( omega ) * (ds_t + ds_b) \
            + ((facet_normal[i] * v[i] - 0) * (facet_normal[j] * nu_v[j])) * sqrt_deth_circle( omega, c_r ) * ds_circle \
    )

# total functional for the mixed problem
F = (F_v + F_w + F_sigma + F_z + F_omega) + F_N

# solve the variational problem
J = derivative( F, psi, J_psi )
problem = NonlinearVariationalProblem( F, psi, bcs, J )
solver = NonlinearVariationalSolver( problem )

solver.solve()

# get the solution and write it to file
v_dummy, w_dummy, sigma_dummy, omega_dummy, z_dummy = psi.split( deepcopy=True )

# print solution to file
xdmffile_v.write( v_dummy, 0 )
xdmffile_w.write( w_dummy, 0 )
xdmffile_sigma.write( sigma_dummy, 0 )
xdmffile_omega.write( omega_dummy, 0 )
xdmffile_z.write( z_dummy, 0 )

# write the solutions in .h5 format so it can be read from other codes 
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/v.h5", "w" ).write( v_dummy, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/w.h5", "w" ).write( w_dummy, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/sigma.h5", "w" ).write( sigma_dummy, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/omega.h5", "w" ).write( omega_dummy, "/f" )
HDF5File( MPI.comm_world, (args.output_directory) + "/h5/z.h5", "w" ).write( z_dummy, "/f" )
'''
