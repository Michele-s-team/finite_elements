
# This file solves for the steady state of a two-dimensional fluid in the presence of tangential flows.
#
# This file needs the mesh files, which can be generated by `finite_elements/mesh/membrane_mesh/generate_mesh.py` with
# $ python3 generate_mesh.py 0.1
# and which are stored into finite_elements/mesh/membrane_mesh/
#
# Run with
# $clear; rm solution/*;  python3 example.py /home/fenics/shared/mesh/membrane_mesh/ /home/fenics/shared/navier_stokes/fenics_example/solution/ 0.01 3
# The solution files will be stored in /home/fenics/shared/navier_stokes/fenics_example/solution/
#
# Note that all sections of the code which need to be changed when an external parameter (e.g., the inflow velocity, the length of the Rectangle, etc...) is changed are bracketed by
# #CHANGE PARAMETERS HERE
#
# issues:
# - on some boundaries w is not constrained bo tbe zero, but z is constrainted to be constant by the BCs -> inconsistent
# - v_n does not satisty the BCs . CHECK : the equation v_n - v_bar  + Deltat \nabla phi + the BC n^i \Nabla phi_i = 0 on \partial_Omega_.... tells you that v_n . n = 0 on \partial_Omega_* -> check if this is true
#


from __future__ import print_function
from fenics import *
from mshr import *
import numpy as np
import argparse
import ufl as ufl
#geometry.py contains all the aspects related to the differential geometry of the problem and function spaces.
from geometry import *

set_log_level(20)

print("Input diredtory = ", args.input_directory)
print("Output diredtory = ", args.output_directory)
print("T = ", T)
print("N = ", N)


# # Create mesh
# channel = Rectangle(Point(0, 0), Point(1.0, 1.0))
# cylinder = Circle(Point(0.2, 0.2), 0.05)
# domain = channel - cylinder
# mesh = generate_mesh(domain, 64)

# Create XDMF files for visualization output
xdmffile_v_n = XDMFFile( (args.output_directory) + '/v_n.xdmf' )
xdmffile_w_n = XDMFFile( (args.output_directory) + '/w_n.xdmf' )
xdmffile_sigma_n = XDMFFile( (args.output_directory) + '/sigma_n.xdmf' )
xdmffile_omega_n = XDMFFile( (args.output_directory) + '/omega_n.xdmf' )
xdmffile_z_n = XDMFFile( (args.output_directory) + '/z_n.xdmf' )

xdmffile_n = XDMFFile((args.output_directory) + '/n.xdmf')
xdmffile_n.write( n_overline_smooth(), 0 )


#read an object with label subdomain_id from xdmf file and assign to it the ds `ds_inner`
mf = dolfin.cpp.mesh.MeshFunctionSizet(mesh, mvc)

#test for surface elements
ds_l = Measure("ds", domain=mesh, subdomain_data=mf, subdomain_id=2)
ds_r = Measure("ds", domain=mesh, subdomain_data=mf, subdomain_id=3)
ds_t = Measure("ds", domain=mesh, subdomain_data=mf, subdomain_id=4)
ds_b = Measure("ds", domain=mesh, subdomain_data=mf, subdomain_id=5)
ds_circle = Measure("ds", domain=mesh, subdomain_data=mf, subdomain_id=6)

# f_test_ds is a scalar function defined on the mesh, that will be used to test whether the boundary elements ds_circle, ds_inflow, ds_outflow, .. are defined correclty . This will be done by computing an integral of f_test_ds over these boundary terms and comparing with the exact result 
f_test_ds = Function( Q_z_n )
f_test_ds = interpolate( FunctionTestIntegralsds( element=Q_z_n.ufl_element() ), Q_z_n )

#here I integrate \int ds 1 over the circle and store the result of the integral as a double in inner_circumference
integral_l = assemble(f_test_ds*ds_l)
integral_r = assemble(f_test_ds*ds_r)
integral_t = assemble(f_test_ds*ds_t)
integral_b = assemble(f_test_ds*ds_b)
integral_circle = assemble(f_test_ds*ds_circle)

#print out the integrals on the surface elements and compare them with the exact values to double check that the elements are tagged correctly
print("Integral l = ", integral_l, " exact value = 0.373169")
print("Integral r = ", integral_r, " exact value = 0.00227783")
print("Integral t = ", integral_t, " exact value = 1.36562")
print("Integral b = ", integral_b, " exact value = 1.02837")
print("Integral circle = ", integral_circle, " exact value = 0.205204")


# Define trial and test functions
nu_v_bar, nu_w_bar, nu_phi, nu_v_n, nu_w_n, nu_omega_n, nu_z_n = TestFunctions(Q)

v_n_1 = Function(Q_v_n)
v_n_2 = Function(Q_v_n)
w_n_1 = Function(Q_w_n)
sigma_n = Function(Q_phi)
sigma_n_1 = Function(Q_phi)
sigma_n_2 = Function(Q_phi)
omega_n_1 = Function(Q_omega_n)
z_n_1 = Function(Q_z_n)




# Define functions for solutions at previous and current time steps
#the function in the total mixed space encorporating vbar, wbar, phi, vn, wn, omegan and zn
psi = Function(Q)
#the Jacobian

J_psi = TrialFunction(Q)
#sigma, v, z, omega are used to store the numerical values of the fields
v_bar, w_bar, phi, v_n, w_n, omega_n, z_n = split( psi )
#vbar_0, ...., zn_0 are used to store the initial conditions
v_bar_0 = Function( Q_v_bar )
w_bar_0 = Function( Q_w_bar )
phi_0 = Function(Q_phi)
sigma_0 = Function(Q_phi)
v_n_0 = Function( Q_v_n )
w_n_0 = Function( Q_w_n )
z_n_0 = Function( Q_z_n )
omega_n_0 = Function( Q_omega_n )

V = (v_bar + v_n_1) / 2.0
W = (w_bar + w_n_1) / 2.0
sigma_ast = (sigma_n_1 + sigma_n_2)/2.0
#w_{n-1/2}
w_n_12 = (w_n + w_n_1) / 2.0
#omega_{n-1/2}
omega_n_12 = (omega_n + omega_n_1) / 2.0
#sigma_{n-1/2}
sigma_n_12 = (sigma_n + sigma_n_1)/2.0


# Define expressions used in variational forms
Deltat = Constant(dt)
kappa = Constant(kappa)
rho = Constant(rho)
#the values of \partial_i z = omega_i on the circle and on the square, to be used in the boundary conditions (BCs) imposed with Nitche's method, in F_N
grad_circle = interpolate( grad_circle_Expression( element=Q_omega_n.ufl_element() ), Q_omega_n )
grad_square = interpolate( grad_square_Expression( element=Q_omega_n.ufl_element() ), Q_omega_n )


# assigner = FunctionAssigner(Q, [Q_v_bar, Q_w_bar, Q_phi, Q_v_n, Q_w_n, Q_omega_n, Q_z_n])
# assigner.assign(psi, [v_bar_0, w_bar_0, phi_0, v_n_0, w_n_0, omega_n_0, z_n_0])


#CHANGE PARAMETERS HERE
C=0.1
l_profile_v = Expression(('C * 4.0*1.5*x[1]*(h - x[1]) / pow(h, 2)', '0'), degree=2, h=h, C=C)
#CHANGE PARAMETERS HERE


# boundary conditions (BCs)
#BCs for v_bar
bc_v_bar_l = DirichletBC(Q.sub(0), l_profile_v, boundary_l)
# bc_v_bar_tb = DirichletBC(Q.sub(0), Constant((0, 0)), boundary_tb)
# bc_v_bar_circle = DirichletBC(Q.sub(0), Constant((0, 0)), boundary_circle)

#BCs for w_bar
bc_w_bar_lr = DirichletBC( Q.sub( 1 ), Constant( 0 ), boundary_lr)
bc_w_bar_tb = DirichletBC( Q.sub( 1 ), Constant( 0 ), boundary_tb)
bc_w_bar_circle = DirichletBC( Q.sub( 1 ), Constant( 0 ), boundary_circle)


#BC for phi
bc_phi = DirichletBC(Q.sub(2), Constant(0), boundary_r)

#CHANGE PARAMETERS HERE
#BCs for z
bc_z_circle = DirichletBC(Q.sub(6), Expression('0.0', element = Q.sub(6).ufl_element()), boundary_circle)
bc_z_square = DirichletBC(Q.sub(6), Expression('0.0', element = Q.sub(6).ufl_element(), h = h), boundary_square)
#CHANGE PARAMETERS HERE

#all BCs
bcs = [bc_v_bar_l, bc_w_bar_lr, bc_w_bar_tb, bc_w_bar_circle, bc_phi, bc_z_circle, bc_z_square]

#set initial profiles
v_n_1 = interpolate(TangentVelocityExpression(element=Q_v_n.ufl_element()), Q_v_n)
v_n_2 = v_n_1
w_n_1 = interpolate(NormalVelocityExpression(element=Q_w_n.ufl_element()), Q_w_n)
sigma_n_1 = interpolate(SurfaceTensionExpression(element=Q_phi.ufl_element()), Q_phi)
sigma_n_2 = sigma_n_1
z_n_1 = interpolate(ManifoldExpression(element=Q_z_n.ufl_element()), Q_z_n)
omega_n_1 = interpolate(OmegaExpression(element=Q_omega_n.ufl_element()), Q_omega_n)


# Time-stepping
for step in range(N):

    print("\n* step = ", step, "\n")

    if step>0:
        #append to the full time series solution at the current step
        xdmffile_v_n.write( v_n_1, step)
        xdmffile_w_n.write( w_n_1, step)
        xdmffile_sigma_n.write( sigma_n_1, step)
        xdmffile_omega_n.write( omega_n_1, step)
        xdmffile_z_n.write( z_n_1, step)

        #write the solution at current step, so, in case the code crashes, it can be read back
        xdmffile_v_n_t = XDMFFile( (args.output_directory) + '/steps' + '/v_n_' + str(step) + '.xdmf' )
        xdmffile_v_n_t.write(v_n_1)
        xdmffile_w_n_t = XDMFFile( (args.output_directory) + '/steps' + '/w_n_' + str(step) + '.xdmf' )
        xdmffile_w_n_t.write(w_n_1)
        xdmffile_sigma_n_t = XDMFFile( (args.output_directory) + '/steps' + '/sigma_n_' + str(step) + '.xdmf' )
        xdmffile_sigma_n_t.write(sigma_n_1)
        xdmffile_omega_n_t = XDMFFile( (args.output_directory) + '/steps' + '/omega_n_' + str(step) + '.xdmf' )
        xdmffile_omega_n_t.write(omega_n_1)
        xdmffile_z_n_t = XDMFFile( (args.output_directory) + '/steps' + '/z_n_' + str(step) + '.xdmf' )
        xdmffile_z_n_t.write(z_n_1)
     

    '''
    Define variational problem : F_vbar, F_wbar .... F_nz are related to the PDEs for vbar, ..., zn respecitvely . F_N enforces the BCs with Nitche's method. 
    To be safe, I explicitly wrote the each term on each part of the boundary with its own normal vector: for example, on the left (l) and on the right (r) sides of the rectangle, 
    the surface elements are ds_l + ds_r, and the normal is n_lr(omega) ~ {+-1 , 0}: this avoids odd interpolations at the corners of the rectangle edges. 
    '''

    F_v_bar = ( \
                          rho * (((v_bar[i] - v_n_1[i]) / Deltat \
                                  + (3.0 / 2.0 * v_n_1[j] - 1.0 / 2.0 * v_n_2[j]) * Nabla_v( V, omega_n_12 )[i, j] \
                                  - 2.0 * V[j] * W * g_c( omega_n_12 )[i, k] * b( omega_n_12 )[k, j]) * nu_v_bar[i] \
                                 + 1.0 / 2.0 * (W ** 2) * g_c( omega_n_12 )[i, j] * Nabla_f( nu_v_bar, omega_n_12 )[
                                     i, j]) \
                          + sigma_ast * g_c( omega_n_12 )[i, j] * Nabla_f( nu_v_bar, omega_n_12 )[i, j] \
                          + 2.0 * eta * d_c( V, W, omega_n_12 )[i, j] * Nabla_f( nu_v_bar, omega_n_12 )[j, i]
              ) * sqrt_detg( omega_n_12 ) * dx \
              - rho / 2.0 * ( \
                          ((W ** 2) * (n_lr( omega_n_12 ))[i] * nu_v_bar[i]) * sqrt_deth_square( omega_n_12 ) * (
                              ds_l + ds_r) \
                          + ((W ** 2) * (n_tb( omega_n_12 ))[i] * nu_v_bar[i]) * sqrt_deth_square( omega_n_12 ) * (
                                      ds_t + ds_b) \
                          + ((W ** 2) * (n( omega_n_12 ))[i] * nu_v_bar[i]) * sqrt_deth_circle( omega_n_12,
                                                                                                c_r ) * ds_circle
              ) \
              - ( \
                          (sigma_ast * (n_lr( omega_n_12 ))[i] * nu_v_bar[i]) * sqrt_deth_square( omega_n_12 ) * (
                              ds_l + ds_r) \
                          + (sigma_ast * (n_tb( omega_n_12 ))[i] * nu_v_bar[i]) * sqrt_deth_square( omega_n_12 ) * (
                                      ds_t + ds_b) \
                          + (sigma_ast * (n( omega_n_12 ))[i] * nu_v_bar[i]) * sqrt_deth_circle( omega_n_12,
                                                                                                 c_r ) * ds_circle
              ) \
              - 2.0 * eta * ( \
                          (d_c( V, W, omega_n_12 )[i, j] * g( omega_n_12 )[i, k] * (n_lr( omega_n_12 ))[k] * nu_v_bar[
                              j]) * sqrt_deth_square( omega_n_12 ) * ds_l \
                          + (d_c( V, W, omega_n_12 )[i, 1] * g( omega_n_12 )[i, k] * (n_lr( omega_n_12 ))[k] * nu_v_bar[
                      1]) * sqrt_deth_square( omega_n_12 ) * ds_r \
                          + (d_c( V, W, omega_n_12 )[i, j] * g( omega_n_12 )[i, k] * (n_tb( omega_n_12 ))[k] * nu_v_bar[
                      j]) * sqrt_deth_square( omega_n_12 ) * (ds_t + ds_b) \
                          + (d_c( V, W, omega_n_12 )[i, j] * g( omega_n_12 )[i, k] * (n( omega_n_12 ))[k] * nu_v_bar[
                      j]) * sqrt_deth_circle( omega_n_12, c_r ) * ds_circle
              )

    F_w_bar = ( \
                          rho * ((w_bar - w_n_1) / Deltat + V[i] * V[k] * b( omega_n_12 )[k, i]) * nu_w_bar \
                          - rho * W *
                          Nabla_v( vector_times_scalar( 3.0 / 2.0 * v_n_1 - 1.0 / 2.0 * v_n_2, nu_w_bar ), omega_n_12 )[
                              i, i] \
                          + 2.0 * kappa * ( \
                                      - g_c( omega_n_12 )[i, j] * ((H( omega_n_12 )).dx( j )) * (nu_w_bar.dx( i )) \
                                      + 2.0 * H( omega_n_12 ) * ((H( omega_n_12 )) ** 2 - K( omega_n_12 )) * nu_w_bar \
                              ) \
                          - ( \
                                      2.0 * sigma_n_12 * H( omega_n_12 ) \
                                      + 2.0 * eta * (g_c( omega_n_12 )[i, k] * Nabla_v( V, omega_n_12 )[j, k] *
                                                     (b( omega_n_12 ))[i, j] - 2.0 * W * (
                                                                 2.0 * (H( omega_n_12 )) ** 2 - K( omega_n_12 )))
                          ) * nu_w_bar
              ) * sqrt_detg( omega_n_12 ) * dx \
              + rho * ( \
                          (W * nu_w_bar * (n_lr( omega_n_12 ))[j] * g( omega_n_12 )[j, i] * (
                                      3.0 / 2.0 * v_n_1[i] - 1.0 / 2.0 * v_n_2[i])) * sqrt_deth_square( omega_n_12 ) * (
                                      ds_l + ds_r) \
                          + (W * nu_w_bar * (n_tb( omega_n_12 ))[j] * g( omega_n_12 )[j, i] * (
                              3.0 / 2.0 * v_n_1[i] - 1.0 / 2.0 * v_n_2[i])) * sqrt_deth_square( omega_n_12 ) * (
                                      ds_t + ds_b) \
                          + (W * nu_w_bar * (n( omega_n_12 ))[j] * g( omega_n_12 )[j, i] * (
                              3.0 / 2.0 * v_n_1[i] - 1.0 / 2.0 * v_n_2[i])) * sqrt_deth_circle( omega_n_12,
                                                                                                c_r ) * ds_circle
              ) \
              + 2.0 * kappa * ( \
                          (nu_w_bar * (n_lr( omega_n_12 ))[i] * ((H( omega_n_12 )).dx( i ))) * sqrt_deth_square(
                      omega_n_12 ) * (ds_l + ds_r) \
                          + (nu_w_bar * (n_tb( omega_n_12 ))[i] * ((H( omega_n_12 )).dx( i ))) * sqrt_deth_square(
                      omega_n_12 ) * (ds_t + ds_b) \
                          + (nu_w_bar * (n( omega_n_12 ))[i] * ((H( omega_n_12 )).dx( i ))) * sqrt_deth_circle(
                      omega_n_12, c_r ) * ds_circle
              )

    F_phi = ( \
                        g_c( omega_n_12 )[i, j] * (phi.dx( i )) * (nu_phi.dx( j )) \
                        + rho / Deltat * (Nabla_v( v_bar, omega_n_12 )[i, i] - 2.0 * H( omega_n_12 ) * w_bar) * nu_phi \
                ) * sqrt_detg( omega_n_12 ) * dx \
            - ((n_lr( omega_n_12 ))[i] * (phi.dx( i )) * nu_phi) * sqrt_deth_square( omega_n_12 ) * ds_r

    F_v_n = ((rho / Deltat * (v_n[i] - v_bar[i]) + g_c( omega_n_12 )[i, j] * (phi.dx( j ))) * nu_v_n[i]) * sqrt_detg(
        omega_n_12 ) * dx

    F_w_n = ((w_n - w_bar) * nu_w_n) * sqrt_detg( omega_n_12 ) * dx

    F_z_n = ( \
                        ( \
                                    (z_n - z_n_1) / Deltat \
                                    - w_n_12 * ((normal( omega_n_12 ))[2] - (
                                        (normal( omega_n_12 ))[0] * omega_n_12[0] + (normal( omega_n_12 ))[1] *
                                        omega_n_12[1])) \
                            ) * nu_z_n \
                ) * sqrt_detg( omega_n_12 ) * dx

    F_omega_n = (z_n * Nabla_v( nu_omega_n, omega_n_12 )[i, i] + omega_n[i] * nu_omega_n[i]) * sqrt_detg(
        omega_n_12 ) * dx \
                - ( \
                            ((n_lr( omega_n_12 ))[i] * g( omega_n_12 )[i, j] * z_n * nu_omega_n[j]) * sqrt_deth_square(
                        omega_n_12 ) * (ds_l + ds_r) \
                            + ((n_tb( omega_n_12 ))[i] * g( omega_n_12 )[i, j] * z_n * nu_omega_n[
                        j]) * sqrt_deth_square( omega_n_12 ) * (ds_t + ds_b) \
                            + ((n( omega_n_12 ))[i] * g( omega_n_12 )[i, j] * z_n * nu_omega_n[j]) * sqrt_deth_circle(
                        omega_n_12, c_r ) * ds_circle
                )

    F_N = alpha * ( \
                (((n_overline_lr())[i] * omega_n[i] - (n_overline_lr())[i] * grad_square[i]) * (
                            (n_overline_lr())[k] * g( omega_n_12 )[k, l] * nu_omega_n[l])) * sqrt_deth_square(
            omega_n_12 ) * (ds_l + ds_r) \
                + (((n_overline_tb())[i] * omega_n[i] - (n_overline_tb())[i] * grad_square[i]) * (
                    (n_overline_tb())[k] * g( omega_n_12 )[k, l] * nu_omega_n[l])) * sqrt_deth_square( omega_n_12 ) * (
                            ds_t + ds_b) \
                + ((n_overline[i] * omega_n[i] - n_overline[i] * grad_circle[i]) * (
                    n_overline[k] * g( omega_n_12 )[k, l] * nu_omega_n[l])) * sqrt_deth_circle( omega_n_12,
                                                                                                c_r ) * ds_circle \
 \
                + (((n_overline_tb())[i] * g( omega_n_12 )[i, j] * v_bar[j] - 0) * (
                    (n_overline_tb())[k] * nu_v_bar[k])) * sqrt_deth_square( omega_n_12 ) * (ds_t + ds_b) \
                + ((n_overline[i] * g( omega_n_12 )[i, j] * v_bar[j] - 0) * (
                    n_overline[k] * nu_v_bar[k])) * sqrt_deth_circle( omega_n_12, c_r ) * ds_circle \
        )

    # total functional for the mixed problem
    F = (F_v_bar + F_w_bar + F_phi + F_v_n + F_w_n + F_z_n + F_omega_n) + F_N

    # solve the variational problem
    J = derivative( F, psi, J_psi )
    problem = NonlinearVariationalProblem( F, psi, bcs, J )
    solver = NonlinearVariationalSolver( problem )

    solver.solve()

    #update previous solution: update v_n_2 and w_n_2
    v_n_2.assign(v_n_1)

    #get the solution and write it to file
    v_bar_, w_bar_, phi_, v_n_1, w_n_1, omega_n_1, z_n_1 = psi.split(deepcopy=True)

    #update previous solution: update sigma
    sigma_n.assign(sigma_n_2-2.0*project(phi_, Q_phi))
    sigma_n_2.assign(sigma_n_1)
    sigma_n_1.assign(sigma_n)