 - to install fenics do
    * start Docker Desktop app
    * take DockerFile in finite_elements folder
    * do 'sudo docker build -t finite_elements .'
    * do 'docker run -ti -v $(pwd):/home/fenics/shared --name fe finite_elements'
    * if you need an additional package, say h5py, 'pip3 install --user h5py'
  - to install with pip3 run 'sudo pip install meshio --trusted-host="pypi.python.org"'


- if you get the error '-------------------  End compiler output  ------------------------
Compilation failed! Sources, command, and errors have been written to: /home/fenics/shared/navier_stokes/fenics_example/jitfailure-ffc_form_17852fbd14c5f68306bd045425549c0cd9aebf3b' then exit and kill the docker container and restart it 

- if you get the error 'integer is not callable' that may be because you defined first a function n(x) and then you re-defined n as a an integer, so when you write n(x) the program is trying to call an integer with an argument. To find out what is going on, on PyCharm the error is highlighted in yellow-brown, use this feature: click on n(x) highlighted in yellow-brown and see that it will redirect you to the integer n -> this will allow you to understand what the code is trying to call 
- in codes that contain a time evolution, if you see that things do not evolve as much as they should or have an odd temporal dependence, ir may be because the variational problem is not updated fully at every time step ->  define the variational problem, the solver and J into the time loop

- df = pd.read_csv('name of file.csv')
 p = df.iloc[0].to_dict()
 p['name of the parameter'] + ....

- use paraview version 5.10.1, the other versions may crash and freeze as soon as you open a file and try to press a button 
- the (?) in Paraview when plotting a field f may be due to the fact that you are allocating a new field at the next time loop, e.g., with f = interpolate(...)
- Be careful that Pycharm intellisense may include some lines that you don't want without you noticing ! 
- BE CAREFUL WHEN YOU WRITE INTO A FIELD: IT MAY ALLOCATE A NEW FIELD WRITTEN IN A NEW MEMORY ADDRESS:
    * if you do
        f = Function(Q) (A)
        g = Function(Q) (B)
        h = f+g
    and then
        f = interpolate( my_expression( element=Q.ufl_element() ), Q ) (C)
    then (C) will re-allocate f, and h will point to the old allocation of f done in (A) and it will not be updated according to (C)
      On the other hand, if you do (A), (B) and
         f_dummy  =    interpolate( my_expression( element=Q.ufl_element() ), Q ) (D)
         f.assign(f_dummy) (E)
    then (D) and (E) will assign my_expression to f by keeping the same memory allocation of f, and g will be updated accordingly.
    * on the other hand, if you do f.interpolate( my_function_Expression( element=Q.ufl_element() ) ), f will not be reallocated and this call to interpolate will write the expression into the already existing memory address of f
    * when writing a field to a file, if you do
        xdmf_file_sigma.write( project(-p_n_12, Q),  t)
    this will allocate a new field at every call of write() and produce a (?) when visualizing the field in Paraview. Instead, do sigma_n_12 = Function(Q) at the beginning of the code and
        sigma_n_12.assign( project(-p_n_12, Q) )
        xdmf_file_sigma.write( sigma_n_12,  t - dt/2.0 )
    which will not yield the (?) in paraview.

    
    * similarly for a function in a mixed space:
        P_omega = VectorElement( 'P', triangle, 3 )
        P_z = FiniteElement( 'P', triangle, 1 )
        element = MixedElement( [P_omega, P_z] )
        Q = FunctionSpace(mesh, element)
        Q_omega = Q.sub(0).collapse()
        Q_z = Q.sub(1).collapse()
        psi = Function( Q )
        assigner.assign(psi, [..., ...])
        h = f + g (A)
        f, z = psi.split( deepcopy=True ) (B)
        then (B) allocates a new f and z and h in (A) will not be updated because it points to the previously allocated f
        


